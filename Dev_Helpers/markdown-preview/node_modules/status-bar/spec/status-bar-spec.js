(function() {
  var $$, StatusBar, WorkspaceView, fs, os, path, _ref;

  _ref = require('atom'), $$ = _ref.$$, WorkspaceView = _ref.WorkspaceView;

  fs = require('fs-plus');

  StatusBar = require('../lib/status-bar');

  path = require('path');

  os = require('os');

  describe("StatusBar", function() {
    var buffer, editor, editorView, statusBar, _ref1;
    _ref1 = [], editor = _ref1[0], editorView = _ref1[1], statusBar = _ref1[2], buffer = _ref1[3];
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspace = atom.workspaceView.model;
      atom.workspaceView.openSync('sample.js');
      atom.workspaceView.simulateDomAttachment();
      StatusBar.activate();
      editorView = atom.workspaceView.getActiveView();
      editor = editorView.getEditor();
      statusBar = atom.workspaceView.find('.status-bar').view();
      return buffer = editor.getBuffer();
    });
    describe("@initialize", function() {
      return it("appends only one status bar", function() {
        expect(atom.workspaceView.vertical.find('.status-bar').length).toBe(1);
        editorView.splitRight();
        return expect(atom.workspaceView.vertical.find('.status-bar').length).toBe(1);
      });
    });
    describe(".initialize(editor)", function() {
      it("displays the editor's buffer path, cursor buffer position, and buffer modified indicator", function() {
        expect(StatusBar.fileInfo.currentPath.text()).toBe('sample.js');
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        return expect(StatusBar.cursorPosition.text()).toBe('1,1');
      });
      return describe("when associated with an unsaved buffer", function() {
        return it("displays 'untitled' instead of the buffer's path, but still displays the buffer position", function() {
          atom.workspaceView.openSync();
          StatusBar.activate();
          statusBar = atom.workspaceView.find('.status-bar').view();
          expect(StatusBar.fileInfo.currentPath.text()).toBe('untitled');
          return expect(StatusBar.cursorPosition.text()).toBe('1,1');
        });
      });
    });
    describe(".deactivate()", function() {
      it("removes the StatusBarView", function() {
        statusBar = atom.workspaceView.find('.status-bar');
        expect(statusBar).toExist();
        expect(atom.workspaceView.statusBar).toBeDefined();
        StatusBar.deactivate();
        statusBar = atom.workspaceView.find('.status-bar');
        expect(statusBar).not.toExist();
        return expect(atom.workspaceView.statusBar).toBeFalsy();
      });
      return it("can be called twice", function() {
        StatusBar.deactivate();
        return StatusBar.deactivate();
      });
    });
    describe("when the associated editor's path changes", function() {
      return it("updates the path in the status bar", function() {
        atom.workspaceView.openSync('sample.txt');
        return expect(StatusBar.fileInfo.currentPath.text()).toBe('sample.txt');
      });
    });
    describe("when the associated editor's buffer's content changes", function() {
      return it("enables the buffer modified indicator", function() {
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        editor.insertText("\n");
        advanceClock(buffer.stoppedChangingDelay);
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('*');
        return editor.backspace();
      });
    });
    describe("when the buffer content has changed from the content on disk", function() {
      it("disables the buffer modified indicator on save", function() {
        var filePath;
        filePath = path.join(os.tmpdir(), "atom-whitespace.txt");
        fs.writeFileSync(filePath, "");
        atom.workspaceView.openSync(filePath);
        editor = atom.workspaceView.getActivePaneItem();
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        editor.insertText("\n");
        advanceClock(buffer.stoppedChangingDelay);
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('*');
        editor.getBuffer().save();
        return expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
      });
      it("disables the buffer modified indicator if the content matches again", function() {
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        editor.insertText("\n");
        advanceClock(buffer.stoppedChangingDelay);
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('*');
        editor.backspace();
        advanceClock(buffer.stoppedChangingDelay);
        return expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
      });
      return it("disables the buffer modified indicator when the change is undone", function() {
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        editor.insertText("\n");
        advanceClock(buffer.stoppedChangingDelay);
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('*');
        editor.undo();
        advanceClock(buffer.stoppedChangingDelay);
        return expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
      });
    });
    describe("when the buffer changes", function() {
      it("updates the buffer modified indicator for the new buffer", function() {
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        atom.workspaceView.openSync('sample.txt');
        editor = atom.workspaceView.getActivePaneItem();
        editor.insertText("\n");
        advanceClock(buffer.stoppedChangingDelay);
        return expect(StatusBar.fileInfo.bufferModified.text()).toBe('*');
      });
      return it("doesn't update the buffer modified indicator for the old buffer", function() {
        var oldBuffer;
        oldBuffer = editor.getBuffer();
        expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
        atom.workspaceView.openSync('sample.txt');
        oldBuffer.setText("new text");
        advanceClock(buffer.stoppedChangingDelay);
        return expect(StatusBar.fileInfo.bufferModified.text()).toBe('');
      });
    });
    describe("when the associated editor's cursor position changes", function() {
      return it("updates the cursor position in the status bar", function() {
        atom.workspaceView.attachToDom();
        editor.setCursorScreenPosition([1, 2]);
        editorView.updateDisplay();
        return expect(StatusBar.cursorPosition.text()).toBe('2,3');
      });
    });
    describe("git branch label", function() {
      beforeEach(function() {
        fs.removeSync(path.join(os.tmpdir(), '.git'));
        return atom.workspaceView.attachToDom();
      });
      it("displays the current branch for files in repositories", function() {
        var view;
        atom.project.setPath(atom.project.resolve('git/master.git'));
        atom.workspaceView.openSync('HEAD');
        expect(StatusBar.git.branchArea).toBeVisible();
        expect(StatusBar.git.branchLabel.text()).toBe('master');
        atom.workspaceView.getActivePaneView().destroyItems();
        expect(StatusBar.git.branchArea).toBeVisible();
        expect(StatusBar.git.branchLabel.text()).toBe('master');
        view = $$(function() {
          return this.div({
            id: 'view',
            tabindex: -1
          }, 'View');
        });
        atom.workspaceView.getActivePaneView().showItem(view);
        return expect(StatusBar.git.branchArea).not.toBeVisible();
      });
      it("doesn't display the current branch for a file not in a repository", function() {
        atom.project.setPath(os.tmpdir());
        atom.workspaceView.openSync(path.join(os.tmpdir(), 'temp.txt'));
        return expect(StatusBar.git.branchArea).toBeHidden();
      });
      return it("doesn't display the current branch for a file outside the current project", function() {
        atom.workspaceView.openSync(path.join(os.tmpdir(), 'atom-specs', 'not-in-project.txt'));
        return expect(StatusBar.git.branchArea).toBeHidden();
      });
    });
    describe("git status label", function() {
      var filePath, ignorePath, ignoredPath, newPath, originalPathText, projectPath, repo, _ref2;
      _ref2 = [], repo = _ref2[0], filePath = _ref2[1], originalPathText = _ref2[2], newPath = _ref2[3], ignorePath = _ref2[4], ignoredPath = _ref2[5], projectPath = _ref2[6];
      beforeEach(function() {
        projectPath = atom.project.resolve('git/working-dir');
        fs.moveSync(path.join(projectPath, 'git.git'), path.join(projectPath, '.git'));
        atom.project.setPath(projectPath);
        filePath = atom.project.resolve('a.txt');
        newPath = atom.project.resolve('new.txt');
        fs.writeFileSync(newPath, "I'm new here");
        ignorePath = path.join(projectPath, '.gitignore');
        fs.writeFileSync(ignorePath, 'ignored.txt');
        ignoredPath = path.join(projectPath, 'ignored.txt');
        fs.writeFileSync(ignoredPath, '');
        atom.project.getRepo().getPathStatus(filePath);
        atom.project.getRepo().getPathStatus(newPath);
        originalPathText = fs.readFileSync(filePath, 'utf8');
        return atom.workspaceView.attachToDom();
      });
      afterEach(function() {
        fs.writeFileSync(filePath, originalPathText);
        fs.removeSync(newPath);
        fs.removeSync(ignorePath);
        fs.removeSync(ignoredPath);
        return fs.moveSync(path.join(projectPath, '.git'), path.join(projectPath, 'git.git'));
      });
      it("displays the modified icon for a changed file", function() {
        fs.writeFileSync(filePath, "i've changed for the worse");
        atom.project.getRepo().getPathStatus(filePath);
        atom.workspaceView.openSync(filePath);
        return expect(StatusBar.git.gitStatusIcon).toHaveClass('icon-diff-modified');
      });
      it("doesn't display the modified icon for an unchanged file", function() {
        atom.workspaceView.openSync(filePath);
        return expect(StatusBar.git.gitStatusIcon).toHaveText('');
      });
      it("displays the new icon for a new file", function() {
        atom.workspaceView.openSync(newPath);
        return expect(StatusBar.git.gitStatusIcon).toHaveClass('icon-diff-added');
      });
      it("displays the ignored icon for an ignored file", function() {
        atom.workspaceView.openSync(ignoredPath);
        return expect(StatusBar.git.gitStatusIcon).toHaveClass('icon-diff-ignored');
      });
      it("updates when a status-changed event occurs", function() {
        fs.writeFileSync(filePath, "i've changed for the worse");
        atom.project.getRepo().getPathStatus(filePath);
        atom.workspaceView.openSync(filePath);
        expect(StatusBar.git.gitStatusIcon).toHaveClass('icon-diff-modified');
        fs.writeFileSync(filePath, originalPathText);
        atom.project.getRepo().getPathStatus(filePath);
        return expect(StatusBar.git.gitStatusIcon).not.toHaveClass('icon-diff-modified');
      });
      it("displays the diff stat for modified files", function() {
        fs.writeFileSync(filePath, "i've changed for the worse");
        atom.project.getRepo().getPathStatus(filePath);
        atom.workspaceView.openSync(filePath);
        return expect(StatusBar.git.gitStatusIcon).toHaveText('+1');
      });
      it("displays the diff stat for new files", function() {
        atom.workspaceView.openSync(newPath);
        return expect(StatusBar.git.gitStatusIcon).toHaveText('+1');
      });
      return it("does not display for files not in the current project", function() {
        atom.workspaceView.openSync('/tmp/atom-specs/not-in-project.txt');
        return expect(StatusBar.git.gitStatusIcon).toBeHidden();
      });
    });
    describe("when the active item view does not implement getCursorBufferPosition()", function() {
      return it("hides the cursor position view", function() {
        var view;
        atom.workspaceView.attachToDom();
        view = $$(function() {
          return this.div({
            id: 'view',
            tabindex: -1
          }, 'View');
        });
        editorView.getPane().showItem(view);
        return expect(StatusBar.cursorPosition).toBeHidden();
      });
    });
    describe("when the active item implements getTitle() but not getPath()", function() {
      return it("displays the title", function() {
        var view;
        atom.workspaceView.attachToDom();
        view = $$(function() {
          return this.div({
            id: 'view',
            tabindex: -1
          }, 'View');
        });
        view.getTitle = (function(_this) {
          return function() {
            return 'View Title';
          };
        })(this);
        editorView.getPane().showItem(view);
        expect(StatusBar.fileInfo.currentPath.text()).toBe('View Title');
        return expect(StatusBar.fileInfo.currentPath).toBeVisible();
      });
    });
    describe("when the active item neither getTitle() nor getPath()", function() {
      return it("hides the path view", function() {
        var view;
        atom.workspaceView.attachToDom();
        view = $$(function() {
          return this.div({
            id: 'view',
            tabindex: -1
          }, 'View');
        });
        editorView.getPane().showItem(view);
        return expect(StatusBar.fileInfo.currentPath).toBeHidden();
      });
    });
    return describe("when the active item's title changes", function() {
      return it("updates the path view with the new title", function() {
        var view;
        atom.workspaceView.attachToDom();
        view = $$(function() {
          return this.div({
            id: 'view',
            tabindex: -1
          }, 'View');
        });
        view.getTitle = (function(_this) {
          return function() {
            return 'View Title';
          };
        })(this);
        editorView.getPane().showItem(view);
        expect(StatusBar.fileInfo.currentPath.text()).toBe('View Title');
        view.getTitle = (function(_this) {
          return function() {
            return 'New Title';
          };
        })(this);
        view.trigger('title-changed');
        return expect(StatusBar.fileInfo.currentPath.text()).toBe('New Title');
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/status-bar/spec/status-bar-spec.js.map
