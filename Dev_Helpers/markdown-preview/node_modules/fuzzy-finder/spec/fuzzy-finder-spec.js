(function() {
  var $, $$, PathLoader, WorkspaceView, fs, path, temp, wrench, _, _ref;

  path = require('path');

  _ = require('underscore-plus');

  _ref = require('atom'), $ = _ref.$, $$ = _ref.$$, WorkspaceView = _ref.WorkspaceView;

  fs = require('fs-plus');

  temp = require('temp');

  wrench = require('wrench');

  PathLoader = require('../lib/path-loader');

  describe('FuzzyFinder', function() {
    var bufferView, gitStatusView, projectView, workspaceView, _ref1;
    _ref1 = [], projectView = _ref1[0], bufferView = _ref1[1], gitStatusView = _ref1[2], workspaceView = _ref1[3];
    beforeEach(function() {
      var fixturesPath, tempPath;
      tempPath = fs.realpathSync(temp.mkdirSync('atom'));
      fixturesPath = atom.project.getPath();
      wrench.copyDirSyncRecursive(fixturesPath, tempPath, {
        forceDelete: true
      });
      atom.project.setPath(path.join(tempPath, 'fuzzy-finder'));
      workspaceView = new WorkspaceView;
      atom.workspaceView = workspaceView;
      atom.workspace = atom.workspaceView.model;
      workspaceView.openSync('sample.js');
      workspaceView.enableKeymap();
      return waitsForPromise(function() {
        return atom.packages.activatePackage('fuzzy-finder').then(function(pack) {
          var fuzzyFinder;
          fuzzyFinder = pack.mainModule;
          projectView = fuzzyFinder.createProjectView();
          bufferView = fuzzyFinder.createBufferView();
          return gitStatusView = fuzzyFinder.createGitStatusView();
        });
      });
    });
    describe("file-finder behavior", function() {
      describe("toggling", function() {
        describe("when the root view's project has a path", function() {
          it("shows the FuzzyFinder or hides it and returns focus to the active editor if it already showing", function() {
            var editor1, editor2, _ref2;
            workspaceView.attachToDom();
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.getActiveView().splitRight();
            _ref2 = workspaceView.getEditorViews(), editor1 = _ref2[0], editor2 = _ref2[1];
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            expect(workspaceView.find('.fuzzy-finder')).toExist();
            expect(projectView.filterEditorView.isFocused).toBeTruthy();
            expect(editor1.isFocused).toBeFalsy();
            expect(editor2.isFocused).toBeFalsy();
            projectView.filterEditorView.insertText('this should not show up next time we toggle');
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            expect(editor1.isFocused).toBeFalsy();
            expect(editor2.isFocused).toBeTruthy();
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            return expect(projectView.filterEditorView.getText()).toBe('');
          });
          it("shows all relative file paths for the current project and selects the first", function() {
            var paths;
            workspaceView.attachToDom();
            projectView.setMaxItems(Infinity);
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            paths = null;
            expect(projectView.find(".loading")).toBeVisible();
            expect(projectView.find(".loading").text().length).toBeGreaterThan(0);
            waitsFor("all project paths to load", 5000, function() {
              paths = projectView.paths;
              return (paths != null ? paths.length : void 0) > 0;
            });
            return runs(function() {
              var filePath, _i, _len;
              expect(paths.length).toBeGreaterThan(0);
              expect(projectView.list.children('li').length).toBe(paths.length);
              for (_i = 0, _len = paths.length; _i < _len; _i++) {
                filePath = paths[_i];
                expect(projectView.list.find("li:contains(" + (path.basename(filePath)) + ")")).toExist();
              }
              expect(projectView.list.children().first()).toHaveClass('selected');
              return expect(projectView.find(".loading")).not.toBeVisible();
            });
          });
          it("only creates a single path loader task", function() {
            workspaceView.attachToDom();
            spyOn(PathLoader, 'startTask').andCallThrough();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            return expect(PathLoader.startTask.callCount).toBe(1);
          });
          it("puts the last active path first", function() {
            workspaceView.attachToDom();
            waitsForPromise(function() {
              return atom.workspace.open('sample.txt');
            });
            waitsForPromise(function() {
              return atom.workspace.open('sample.js');
            });
            runs(function() {
              projectView.setMaxItems(Infinity);
              return workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            });
            waitsFor("all project paths to load", 5000, function() {
              var _ref2;
              return ((_ref2 = projectView.paths) != null ? _ref2.length : void 0) > 0;
            });
            return runs(function() {
              expect(projectView.list.find("li:eq(0)").text()).toContain('sample.txt');
              return expect(projectView.list.find("li:eq(1)").text()).toContain('sample.js');
            });
          });
          return describe("symlinks on #darwin or #linux", function() {
            beforeEach(function() {
              fs.symlinkSync(atom.project.resolve('sample.txt'), atom.project.resolve('symlink-to-file'));
              return fs.symlinkSync(atom.project.resolve('dir'), atom.project.resolve('symlink-to-dir'));
            });
            it("includes symlinked file paths", function() {
              workspaceView.attachToDom();
              projectView.setMaxItems(Infinity);
              workspaceView.trigger('fuzzy-finder:toggle-file-finder');
              waitsFor("all project paths to load", 5000, function() {
                var _ref2;
                return ((_ref2 = projectView.paths) != null ? _ref2.length : void 0) > 0;
              });
              return runs(function() {
                return expect(projectView.list.find("li:contains(symlink-to-file)")).toExist();
              });
            });
            return it("excludes symlinked folder paths", function() {
              workspaceView.attachToDom();
              projectView.setMaxItems(Infinity);
              workspaceView.trigger('fuzzy-finder:toggle-file-finder');
              waitsFor("all project paths to load", 5000, function() {
                return !projectView.reloadPaths;
              });
              return runs(function() {
                return expect(projectView.list.find("li:contains(symlink-to-dir)")).not.toExist();
              });
            });
          });
        });
        return describe("when root view's project has no path", function() {
          beforeEach(function() {
            return atom.project.setPath(null);
          });
          return it("does not open the FuzzyFinder", function() {
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            return expect(workspaceView.find('.fuzzy-finder')).not.toExist();
          });
        });
      });
      return describe("when a path selection is confirmed", function() {
        it("opens the file associated with that path in that split", function() {
          var editor1, editor2, expectedPath;
          workspaceView.attachToDom();
          editor1 = workspaceView.getActiveView();
          editor2 = editor1.splitRight();
          expect(workspaceView.getActiveView()).toBe(editor2);
          workspaceView.trigger('fuzzy-finder:toggle-file-finder');
          expectedPath = atom.project.resolve('dir/a');
          projectView.confirmed({
            filePath: expectedPath
          });
          waitsFor(function() {
            return workspaceView.getActivePane().getItems().length === 2;
          });
          return runs(function() {
            var editor3;
            editor3 = workspaceView.getActiveView();
            expect(projectView.hasParent()).toBeFalsy();
            expect(editor1.editor.getPath()).not.toBe(expectedPath);
            expect(editor2.editor.getPath()).not.toBe(expectedPath);
            expect(editor3.editor.getPath()).toBe(expectedPath);
            return expect(editor3.isFocused).toBeTruthy();
          });
        });
        return describe("when the selected path is a directory", function() {
          return it("leaves the the tree view open, doesn't open the path in the editor, and displays an error", function() {
            var editorPath;
            workspaceView.attachToDom();
            editorPath = workspaceView.getActivePaneItem().getPath();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            projectView.confirmed({
              filePath: atom.project.resolve('dir')
            });
            expect(projectView.hasParent()).toBeTruthy();
            expect(workspaceView.getActivePaneItem().getPath()).toBe(editorPath);
            expect(projectView.error.text().length).toBeGreaterThan(0);
            advanceClock(2000);
            return expect(projectView.error.text().length).toBe(0);
          });
        });
      });
    });
    describe("buffer-finder behavior", function() {
      describe("toggling", function() {
        describe("when there are pane items with paths", function() {
          beforeEach(function() {
            workspaceView.attachToDom();
            return workspaceView.openSync('sample.txt');
          });
          it("shows the FuzzyFinder if it isn't showing, or hides it and returns focus to the active editor", function() {
            var editor1, editor2, editor3, _ref2;
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.getActiveView().splitRight();
            _ref2 = workspaceView.getEditorViews(), editor1 = _ref2[0], editor2 = _ref2[1], editor3 = _ref2[2];
            expect(workspaceView.getActiveView()).toBe(editor3);
            expect(editor1.isFocused).toBeFalsy();
            expect(editor2.isFocused).toBeFalsy();
            expect(editor3.isFocused).toBeTruthy();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(workspaceView.find('.fuzzy-finder')).toExist();
            expect(workspaceView.find('.fuzzy-finder input:focus')).toExist();
            bufferView.filterEditorView.insertText('this should not show up next time we toggle');
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(editor1.isFocused).toBeFalsy();
            expect(editor2.isFocused).toBeFalsy();
            expect(editor3.isFocused).toBeTruthy();
            expect(workspaceView.find('.fuzzy-finder')).not.toExist();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            return expect(bufferView.filterEditorView.getText()).toBe('');
          });
          it("lists the paths of the current items, sorted by most recently opened but with the current item last", function() {
            workspaceView.openSync('sample-with-tabs.coffee');
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(_.pluck(bufferView.list.find('li > div.file'), 'outerText')).toEqual(['sample.txt', 'sample.js', 'sample-with-tabs.coffee']);
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            workspaceView.openSync('sample.txt');
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(_.pluck(bufferView.list.find('li > div.file'), 'outerText')).toEqual(['sample-with-tabs.coffee', 'sample.js', 'sample.txt']);
            return expect(bufferView.list.children().first()).toHaveClass('selected');
          });
          return it("serializes the list of paths and their last opened time", function() {
            var bufferPath, paths, states, time, _i, _len, _ref2, _results;
            workspaceView.openSync('sample-with-tabs.coffee');
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            workspaceView.openSync('sample.js');
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            workspaceView.openSync();
            atom.packages.deactivatePackage('fuzzy-finder');
            states = _.map(atom.packages.getPackageState('fuzzy-finder'), function(path, time) {
              return [path, time];
            });
            expect(states.length).toBe(3);
            states = _.sortBy(states, function(path, time) {
              return -time;
            });
            paths = ['sample-with-tabs.coffee', 'sample.txt', 'sample.js'];
            _results = [];
            for (_i = 0, _len = states.length; _i < _len; _i++) {
              _ref2 = states[_i], time = _ref2[0], bufferPath = _ref2[1];
              expect(_.last(bufferPath.split(path.sep))).toBe(paths.shift());
              _results.push(expect(time).toBeGreaterThan(50000));
            }
            return _results;
          });
        });
        describe("when there are only panes with anonymous items", function() {
          return it("does not open", function() {
            workspaceView.getActivePane().remove();
            workspaceView.openSync();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            return expect(workspaceView.find('.fuzzy-finder')).not.toExist();
          });
        });
        describe("when there are no pane items", function() {
          return it("does not open", function() {
            workspaceView.getActivePane().remove();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            return expect(workspaceView.find('.fuzzy-finder')).not.toExist();
          });
        });
        return describe("when multiple sessions are opened on the same path", function() {
          return it("does not display duplicates for that path in the list", function() {
            workspaceView.openSync('sample.js');
            workspaceView.getActiveView().splitRight();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            return expect(_.pluck(bufferView.list.find('li > div.file'), 'outerText')).toEqual(['sample.js']);
          });
        });
      });
      return describe("when a path selection is confirmed", function() {
        var editor1, editor2, editor3, _ref2;
        _ref2 = [], editor1 = _ref2[0], editor2 = _ref2[1], editor3 = _ref2[2];
        beforeEach(function() {
          var _ref3;
          workspaceView.attachToDom();
          editor1 = workspaceView.getActiveView();
          editor2 = editor1.splitRight();
          editor3 = workspaceView.openSync('sample.txt');
          _ref3 = workspaceView.getEditorViews(), editor1 = _ref3[0], editor2 = _ref3[1], editor3 = _ref3[2];
          expect(workspaceView.getActiveView()).toBe(editor3);
          editor2.trigger('pane:show-previous-item');
          return workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        });
        describe("when the active pane has an item for the selected path", function() {
          return it("switches to the item for the selected path", function() {
            var expectedPath;
            expectedPath = atom.project.resolve('sample.txt');
            bufferView.confirmed({
              filePath: expectedPath
            });
            waitsFor(function() {
              return workspaceView.getActivePaneItem().getPath() === expectedPath;
            });
            return runs(function() {
              expect(bufferView.hasParent()).toBeFalsy();
              expect(editor1.editor.getPath()).not.toBe(expectedPath);
              expect(editor2.editor.getPath()).not.toBe(expectedPath);
              expect(editor3.editor.getPath()).toBe(expectedPath);
              return expect(editor3.isFocused).toBeTruthy();
            });
          });
        });
        return describe("when the active pane does not have an item for the selected path", function() {
          return it("adds a new item to the active pane for the selcted path", function() {
            var expectedPath;
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            editor1.focus();
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(workspaceView.getActiveView()).toBe(editor1);
            expectedPath = atom.project.resolve('sample.txt');
            bufferView.confirmed({
              filePath: expectedPath
            });
            waitsFor(function() {
              return workspaceView.getActivePane().getItems().length === 2;
            });
            return runs(function() {
              var editor4;
              editor4 = workspaceView.getActiveView();
              expect(bufferView.hasParent()).toBeFalsy();
              expect(editor1.isFocused).toBeFalsy();
              expect(editor4).not.toBe(editor1);
              expect(editor4).not.toBe(editor2);
              expect(editor4).not.toBe(editor3);
              expect(editor4.editor.getPath()).toBe(expectedPath);
              return expect(editor4.isFocused).toBeTruthy();
            });
          });
        });
      });
    });
    describe("common behavior between file and buffer finder", function() {
      return describe("when the fuzzy finder is cancelled", function() {
        describe("when an editor is open", function() {
          return it("detaches the finder and focuses the previously focused element", function() {
            var activeEditor;
            workspaceView.attachToDom();
            activeEditor = workspaceView.getActiveView();
            activeEditor.focus();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            expect(projectView.hasParent()).toBeTruthy();
            expect(activeEditor.isFocused).toBeFalsy();
            expect(projectView.filterEditorView.isFocused).toBeTruthy();
            projectView.cancel();
            expect(projectView.hasParent()).toBeFalsy();
            expect(activeEditor.isFocused).toBeTruthy();
            return expect(projectView.filterEditorView.isFocused).toBeFalsy();
          });
        });
        return describe("when no editors are open", function() {
          return it("detaches the finder and focuses the previously focused element", function() {
            var inputView;
            workspaceView.attachToDom();
            workspaceView.getActivePane().remove();
            inputView = $$(function() {
              return this.input();
            });
            workspaceView.append(inputView);
            inputView.focus();
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            expect(projectView.hasParent()).toBeTruthy();
            expect(projectView.filterEditorView.isFocused).toBeTruthy();
            projectView.cancel();
            expect(projectView.hasParent()).toBeFalsy();
            expect(document.activeElement).toBe(inputView[0]);
            return expect(projectView.filterEditorView.isFocused).toBeFalsy();
          });
        });
      });
    });
    describe("cached file paths", function() {
      it("caches file paths after first time", function() {
        spyOn(PathLoader, "startTask").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-file-finder');
        waitsFor(function() {
          return projectView.list.children('li').length > 0;
        });
        runs(function() {
          expect(PathLoader.startTask).toHaveBeenCalled();
          PathLoader.startTask.reset();
          workspaceView.trigger('fuzzy-finder:toggle-file-finder');
          return workspaceView.trigger('fuzzy-finder:toggle-file-finder');
        });
        waitsFor(function() {
          return projectView.list.children('li').length > 0;
        });
        return runs(function() {
          return expect(PathLoader.startTask).not.toHaveBeenCalled();
        });
      });
      it("doesn't cache buffer paths", function() {
        spyOn(atom.project, "getEditors").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        waitsFor(function() {
          return bufferView.list.children('li').length > 0;
        });
        runs(function() {
          expect(atom.project.getEditors).toHaveBeenCalled();
          atom.project.getEditors.reset();
          workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
          return workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        });
        waitsFor(function() {
          return bufferView.list.children('li').length > 0;
        });
        return runs(function() {
          return expect(atom.project.getEditors).toHaveBeenCalled();
        });
      });
      return it("busts the cache when the window gains focus", function() {
        spyOn(PathLoader, "startTask").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-file-finder');
        waitsFor(function() {
          return projectView.list.children('li').length > 0;
        });
        return runs(function() {
          expect(PathLoader.startTask).toHaveBeenCalled();
          PathLoader.startTask.reset();
          $(window).triggerHandler('focus');
          workspaceView.trigger('fuzzy-finder:toggle-file-finder');
          workspaceView.trigger('fuzzy-finder:toggle-file-finder');
          return expect(PathLoader.startTask).toHaveBeenCalled();
        });
      });
    });
    it("ignores paths that match entries in config.fuzzy-finder.ignoredNames", function() {
      atom.config.set("fuzzy-finder.ignoredNames", ["sample.js", "*.txt"]);
      workspaceView.trigger('fuzzy-finder:toggle-file-finder');
      projectView.setMaxItems(Infinity);
      waitsFor(function() {
        return projectView.list.children('li').length > 0;
      });
      return runs(function() {
        expect(projectView.list.find("li:contains(sample.js)")).not.toExist();
        expect(projectView.list.find("li:contains(sample.txt)")).not.toExist();
        return expect(projectView.list.find("li:contains(a)")).toExist();
      });
    });
    describe("opening a path into a split", function() {
      it("opens the path by splitting the active editor left", function() {
        var filePath, pane;
        expect(workspaceView.getPanes().length).toBe(1);
        pane = workspaceView.getActivePane();
        spyOn(pane, "splitLeft").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        filePath = bufferView.getSelectedItem().filePath;
        bufferView.filterEditorView.trigger('pane:split-left');
        waitsFor(function() {
          return workspaceView.getPanes().length === 2;
        });
        return runs(function() {
          expect(workspaceView.getPanes().length).toBe(2);
          expect(pane.splitLeft).toHaveBeenCalled();
          return expect(workspaceView.getActivePaneItem().getPath()).toBe(atom.project.resolve(filePath));
        });
      });
      it("opens the path by splitting the active editor right", function() {
        var filePath, pane;
        expect(workspaceView.getPanes().length).toBe(1);
        pane = workspaceView.getActivePane();
        spyOn(pane, "splitRight").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        filePath = bufferView.getSelectedItem().filePath;
        bufferView.filterEditorView.trigger('pane:split-right');
        waitsFor(function() {
          return workspaceView.getPanes().length === 2;
        });
        return runs(function() {
          expect(workspaceView.getPanes().length).toBe(2);
          expect(pane.splitRight).toHaveBeenCalled();
          return expect(workspaceView.getActivePaneItem().getPath()).toBe(atom.project.resolve(filePath));
        });
      });
      it("opens the path by splitting the active editor up", function() {
        var filePath, pane;
        expect(workspaceView.getPanes().length).toBe(1);
        pane = workspaceView.getActivePane();
        spyOn(pane, "splitUp").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        filePath = bufferView.getSelectedItem().filePath;
        bufferView.filterEditorView.trigger('pane:split-up');
        waitsFor(function() {
          return workspaceView.getPanes().length === 2;
        });
        return runs(function() {
          expect(workspaceView.getPanes().length).toBe(2);
          expect(pane.splitUp).toHaveBeenCalled();
          return expect(workspaceView.getActivePaneItem().getPath()).toBe(atom.project.resolve(filePath));
        });
      });
      return it("opens the path by splitting the active editor down", function() {
        var filePath, pane;
        expect(workspaceView.getPanes().length).toBe(1);
        pane = workspaceView.getActivePane();
        spyOn(pane, "splitDown").andCallThrough();
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        filePath = bufferView.getSelectedItem().filePath;
        bufferView.filterEditorView.trigger('pane:split-down');
        waitsFor(function() {
          return workspaceView.getPanes().length === 2;
        });
        return runs(function() {
          expect(workspaceView.getPanes().length).toBe(2);
          expect(pane.splitDown).toHaveBeenCalled();
          return expect(workspaceView.getActivePaneItem().getPath()).toBe(atom.project.resolve(filePath));
        });
      });
    });
    describe("when the filter text contains a colon followed by a number", function() {
      return it("opens the selected path to that line number", function() {
        var editorView;
        workspaceView.attachToDom();
        expect(workspaceView.find('.fuzzy-finder')).not.toExist();
        editorView = workspaceView.getEditorViews()[0];
        expect(editorView.editor.getCursorBufferPosition()).toEqual([0, 0]);
        workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
        expect(workspaceView.find('.fuzzy-finder')).toExist();
        bufferView.filterEditorView.insertText(':4');
        bufferView.trigger('core:confirm');
        spyOn(bufferView, 'moveToLine').andCallThrough();
        waitsFor(function() {
          return bufferView.moveToLine.callCount > 0;
        });
        runs(function() {
          bufferView.moveToLine.reset();
          expect(editorView.editor.getCursorBufferPosition()).toEqual([3, 4]);
          workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
          expect(workspaceView.find('.fuzzy-finder')).toExist();
          bufferView.filterEditorView.insertText(':10');
          return bufferView.filterEditorView.trigger('pane:split-left');
        });
        waitsFor(function() {
          return bufferView.moveToLine.callCount > 0;
        });
        return runs(function() {
          expect(workspaceView.getActiveView()).not.toBe(editorView);
          return expect(workspaceView.getActiveView().editor.getCursorBufferPosition()).toEqual([9, 2]);
        });
      });
    });
    return describe("Git integration", function() {
      var projectPath;
      projectPath = [][0];
      beforeEach(function() {
        projectPath = atom.project.resolve('git/working-dir');
        fs.moveSync(path.join(projectPath, 'git.git'), path.join(projectPath, '.git'));
        return atom.project.setPath(projectPath);
      });
      describe("git-status-finder behavior", function() {
        var newPath, originalPath, originalText, _ref2;
        _ref2 = [], originalText = _ref2[0], originalPath = _ref2[1], newPath = _ref2[2];
        beforeEach(function() {
          var editor;
          editor = workspaceView.openSync('a.txt');
          originalText = editor.getText();
          originalPath = editor.getPath();
          fs.writeFileSync(originalPath, 'making a change for the better');
          atom.project.getRepo().getPathStatus(originalPath);
          newPath = atom.project.resolve('newsample.js');
          fs.writeFileSync(newPath, '');
          return atom.project.getRepo().getPathStatus(newPath);
        });
        return it("displays all new and modified paths", function() {
          expect(workspaceView.find('.fuzzy-finder')).not.toExist();
          workspaceView.trigger('fuzzy-finder:toggle-git-status-finder');
          expect(workspaceView.find('.fuzzy-finder')).toExist();
          expect(gitStatusView.find('.file').length).toBe(2);
          expect(gitStatusView.find('.status.status-modified').length).toBe(1);
          return expect(gitStatusView.find('.status.status-added').length).toBe(1);
        });
      });
      describe("status decorations", function() {
        var editor, newPath, originalPath, originalText, _ref2;
        _ref2 = [], originalText = _ref2[0], originalPath = _ref2[1], editor = _ref2[2], newPath = _ref2[3];
        beforeEach(function() {
          workspaceView.attachToDom();
          editor = workspaceView.openSync('a.txt');
          originalText = editor.getText();
          originalPath = editor.getPath();
          newPath = atom.project.resolve('newsample.js');
          return fs.writeFileSync(newPath, '');
        });
        describe("when a modified file is shown in the list", function() {
          return it("displays the modified icon", function() {
            editor.setText('modified');
            editor.save();
            atom.project.getRepo().getPathStatus(editor.getPath());
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(bufferView.find('.status.status-modified').length).toBe(1);
            return expect(bufferView.find('.status.status-modified').closest('li').find('.file').text()).toBe('a.txt');
          });
        });
        return describe("when a new file is shown in the list", function() {
          return it("displays the new icon", function() {
            editor = workspaceView.openSync('newsample.js');
            atom.project.getRepo().getPathStatus(editor.getPath());
            workspaceView.trigger('fuzzy-finder:toggle-buffer-finder');
            expect(bufferView.find('.status.status-added').length).toBe(1);
            return expect(bufferView.find('.status.status-added').closest('li').find('.file').text()).toBe('newsample.js');
          });
        });
      });
      return describe("when core.excludeVcsIgnoredPaths is set to true", function() {
        beforeEach(function() {
          return atom.config.set("core.excludeVcsIgnoredPaths", true);
        });
        describe("when the project's path is the repository's working directory", function() {
          var ignoreFile, ignoredFile, _ref2;
          _ref2 = [], ignoreFile = _ref2[0], ignoredFile = _ref2[1];
          beforeEach(function() {
            ignoreFile = path.join(atom.project.getPath(), '.gitignore');
            fs.writeFileSync(ignoreFile, 'ignored.txt');
            ignoredFile = path.join(projectPath, 'ignored.txt');
            fs.writeFileSync(ignoredFile, 'ignored text');
            return atom.config.set("core.excludeVcsIgnoredPaths", true);
          });
          return it("excludes paths that are git ignored", function() {
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            projectView.setMaxItems(Infinity);
            waitsFor(function() {
              return projectView.list.children('li').length > 0;
            });
            return runs(function() {
              return expect(projectView.list.find("li:contains(ignored.txt)")).not.toExist();
            });
          });
        });
        return describe("when the project's path is a subfolder of the repository's working directory", function() {
          var ignoreFile;
          ignoreFile = [][0];
          beforeEach(function() {
            atom.project.setPath(atom.project.resolve('dir'));
            ignoreFile = path.join(atom.project.getPath(), '.gitignore');
            return fs.writeFileSync(ignoreFile, 'b.txt');
          });
          return it("does not exclude paths that are git ignored", function() {
            workspaceView.trigger('fuzzy-finder:toggle-file-finder');
            projectView.setMaxItems(Infinity);
            waitsFor(function() {
              return projectView.list.children('li').length > 0;
            });
            return runs(function() {
              return expect(projectView.list.find("li:contains(b.txt)")).toExist();
            });
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/fuzzy-finder/spec/fuzzy-finder-spec.js.map
