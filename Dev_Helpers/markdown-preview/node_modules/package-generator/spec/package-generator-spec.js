(function() {
  var WorkspaceView, fs, path, temp;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  WorkspaceView = require('atom').WorkspaceView;

  describe('Package Generator', function() {
    var activationPromise;
    activationPromise = [][0];
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.openSync('sample.js');
      return activationPromise = atom.packages.activatePackage("package-generator");
    });
    describe("when package-generator:generate-package is triggered", function() {
      return it("displays a miniEditor with the correct text selected", function() {
        atom.workspaceView.trigger("package-generator:generate-package");
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var packageGeneratorView, themeName;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          themeName = packageGeneratorView.miniEditor.editor.getSelectedText();
          return expect(themeName).toEqual('my-package');
        });
      });
    });
    describe("when package-generator:generate-theme is triggered", function() {
      return it("displays a miniEditor with correct text selected", function() {
        atom.workspaceView.trigger("package-generator:generate-syntax-theme");
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var packageGeneratorView, themeName;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          themeName = packageGeneratorView.miniEditor.editor.getSelectedText();
          return expect(themeName).toEqual('my-theme');
        });
      });
    });
    describe("when core:cancel is triggered", function() {
      return it("detaches from the DOM and focuses the the previously focused element", function() {
        atom.workspaceView.attachToDom();
        atom.workspaceView.trigger("package-generator:generate-package");
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var packageGeneratorView;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          expect(packageGeneratorView.miniEditor.isFocused).toBeTruthy();
          expect(atom.workspaceView.getActiveView().isFocused).toBeFalsy();
          packageGeneratorView.trigger("core:cancel");
          expect(packageGeneratorView.hasParent()).toBeFalsy();
          return expect(atom.workspaceView.getActiveView().isFocused).toBeTruthy();
        });
      });
    });
    return describe("when a package is generated", function() {
      var packageName, packagePath, packageRoot, _ref;
      _ref = [], packageName = _ref[0], packagePath = _ref[1], packageRoot = _ref[2];
      beforeEach(function() {
        spyOn(atom, "open");
        packageRoot = temp.mkdirSync('atom');
        packageName = "sweet-package-dude";
        packagePath = path.join(packageRoot, packageName);
        return fs.removeSync(packageRoot);
      });
      afterEach(function() {
        return fs.removeSync(packageRoot);
      });
      it("forces the package's name to be lowercase with dashes", function() {
        packageName = "CamelCaseIsForTheBirds";
        packagePath = path.join(path.dirname(packagePath), packageName);
        atom.workspaceView.trigger("package-generator:generate-package");
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var apmExecute, packageGeneratorView;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          packageGeneratorView.miniEditor.setText(packagePath);
          apmExecute = spyOn(packageGeneratorView, 'runCommand');
          packageGeneratorView.trigger("core:confirm");
          expect(apmExecute).toHaveBeenCalled();
          expect(apmExecute.mostRecentCall.args[0]).toBe(atom.packages.getApmPath());
          return expect(apmExecute.mostRecentCall.args[1]).toEqual(['init', '--package', "" + (path.join(path.dirname(packagePath), "camel-case-is-for-the-birds"))]);
        });
      });
      describe('when creating a package', function() {
        beforeEach(function() {
          atom.workspaceView.trigger("package-generator:generate-package");
          return waitsForPromise(function() {
            return activationPromise;
          });
        });
        describe("when the package is created outside of the packages directory", function() {
          return it("calls `apm init` and `apm link`", function() {
            var apmExecute, packageGeneratorView;
            packageGeneratorView = atom.workspaceView.find(".package-generator").view();
            expect(packageGeneratorView.hasParent()).toBeTruthy();
            packageGeneratorView.miniEditor.setText(packagePath);
            apmExecute = spyOn(packageGeneratorView, 'runCommand').andCallFake(function(command, args, exit) {
              return process.nextTick(function() {
                return exit();
              });
            });
            packageGeneratorView.trigger("core:confirm");
            waitsFor(function() {
              return atom.open.callCount === 1;
            });
            return runs(function() {
              expect(apmExecute.argsForCall[0][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[0][1]).toEqual(['init', '--package', "" + packagePath]);
              expect(apmExecute.argsForCall[1][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[1][1]).toEqual(['link', "" + packagePath]);
              return expect(atom.open.argsForCall[0][0].pathsToOpen[0]).toBe(packagePath);
            });
          });
        });
        return describe("when the package is created inside the packages directory", function() {
          return it("calls `apm init`", function() {
            var apmExecute, packageGeneratorView;
            spyOn(atom.packages, 'getPackageDirPaths').andReturn([packageRoot]);
            packageGeneratorView = atom.workspaceView.find(".package-generator").view();
            expect(packageGeneratorView.hasParent()).toBeTruthy();
            packageGeneratorView.miniEditor.setText(packagePath);
            apmExecute = spyOn(packageGeneratorView, 'runCommand').andCallFake(function(command, args, exit) {
              return process.nextTick(function() {
                return exit();
              });
            });
            packageGeneratorView.trigger("core:confirm");
            waitsFor(function() {
              return atom.open.callCount;
            });
            return runs(function() {
              expect(apmExecute.argsForCall[0][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[0][1]).toEqual(['init', '--package', "" + packagePath]);
              return expect(atom.open.argsForCall[0][0].pathsToOpen[0]).toBe(packagePath);
            });
          });
        });
      });
      describe('when creating a theme', function() {
        beforeEach(function() {
          atom.workspaceView.trigger("package-generator:generate-syntax-theme");
          return waitsForPromise(function() {
            return activationPromise;
          });
        });
        describe("when the theme is created outside of the packages directory", function() {
          return it("calls `apm init` and `apm link`", function() {
            var apmExecute, packageGeneratorView;
            packageGeneratorView = atom.workspaceView.find(".package-generator").view();
            expect(packageGeneratorView.hasParent()).toBeTruthy();
            packageGeneratorView.miniEditor.setText(packagePath);
            apmExecute = spyOn(packageGeneratorView, 'runCommand').andCallFake(function(command, args, exit) {
              return process.nextTick(function() {
                return exit();
              });
            });
            packageGeneratorView.trigger("core:confirm");
            waitsFor(function() {
              return atom.open.callCount === 1;
            });
            return runs(function() {
              expect(apmExecute.argsForCall[0][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[0][1]).toEqual(['init', '--theme', "" + packagePath]);
              expect(apmExecute.argsForCall[1][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[1][1]).toEqual(['link', "" + packagePath]);
              return expect(atom.open.argsForCall[0][0].pathsToOpen[0]).toBe(packagePath);
            });
          });
        });
        return describe("when the theme is created inside of the packages directory", function() {
          return it("calls `apm init`", function() {
            var apmExecute, packageGeneratorView;
            spyOn(atom.packages, 'getPackageDirPaths').andReturn([packageRoot]);
            packageGeneratorView = atom.workspaceView.find(".package-generator").view();
            expect(packageGeneratorView.hasParent()).toBeTruthy();
            packageGeneratorView.miniEditor.setText(packagePath);
            apmExecute = spyOn(packageGeneratorView, 'runCommand').andCallFake(function(command, args, exit) {
              return process.nextTick(function() {
                return exit();
              });
            });
            packageGeneratorView.trigger("core:confirm");
            waitsFor(function() {
              return atom.open.callCount === 1;
            });
            return runs(function() {
              expect(apmExecute.argsForCall[0][0]).toBe(atom.packages.getApmPath());
              expect(apmExecute.argsForCall[0][1]).toEqual(['init', '--theme', "" + packagePath]);
              return expect(atom.open.argsForCall[0][0].pathsToOpen[0]).toBe(packagePath);
            });
          });
        });
      });
      it("displays an error when the package path already exists", function() {
        atom.workspaceView.attachToDom();
        fs.makeTreeSync(packagePath);
        atom.workspaceView.trigger("package-generator:generate-package");
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var packageGeneratorView;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          expect(packageGeneratorView.hasParent()).toBeTruthy();
          expect(packageGeneratorView.error).not.toBeVisible();
          packageGeneratorView.miniEditor.setText(packagePath);
          packageGeneratorView.trigger("core:confirm");
          expect(packageGeneratorView.hasParent()).toBeTruthy();
          return expect(packageGeneratorView.error).toBeVisible();
        });
      });
      return it("opens the package", function() {
        atom.workspaceView.trigger("package-generator:generate-package");
        waitsForPromise(function() {
          return activationPromise;
        });
        runs(function() {
          var apmExecute, loadPackage, packageGeneratorView;
          packageGeneratorView = atom.workspaceView.find(".package-generator").view();
          packageGeneratorView.miniEditor.setText(packagePath);
          apmExecute = spyOn(packageGeneratorView, 'runCommand').andCallFake(function(command, args, exit) {
            return process.nextTick(function() {
              return exit();
            });
          });
          loadPackage = spyOn(atom.packages, 'loadPackage');
          return packageGeneratorView.trigger("core:confirm");
        });
        waitsFor(function() {
          return atom.open.callCount === 1;
        });
        return runs(function() {
          return expect(atom.open).toHaveBeenCalledWith({
            pathsToOpen: [packagePath]
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/package-generator/spec/package-generator-spec.js.map
