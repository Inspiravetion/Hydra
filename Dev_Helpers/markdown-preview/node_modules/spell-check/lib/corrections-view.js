(function() {
  var CorrectionsView, Range, SelectListView, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('atom'), Range = _ref.Range, SelectListView = _ref.SelectListView;

  module.exports = CorrectionsView = (function(_super) {
    __extends(CorrectionsView, _super);

    function CorrectionsView() {
      return CorrectionsView.__super__.constructor.apply(this, arguments);
    }

    CorrectionsView.prototype.initialize = function(editorView, corrections, misspellingRange) {
      this.editorView = editorView;
      this.corrections = corrections;
      this.misspellingRange = misspellingRange;
      CorrectionsView.__super__.initialize.apply(this, arguments);
      this.addClass('corrections popover-list');
      return this.attach();
    };

    CorrectionsView.prototype.viewForItem = function(word) {
      var element;
      element = document.createElement('li');
      element.textContent = word;
      return element;
    };

    CorrectionsView.prototype.selectNextItemView = function() {
      CorrectionsView.__super__.selectNextItemView.apply(this, arguments);
      return false;
    };

    CorrectionsView.prototype.selectPreviousItemView = function() {
      CorrectionsView.__super__.selectPreviousItemView.apply(this, arguments);
      return false;
    };

    CorrectionsView.prototype.confirmed = function(correction) {
      var editor;
      this.cancel();
      if (!correction) {
        return;
      }
      editor = this.editorView.getEditor();
      editor.transact((function(_this) {
        return function() {
          editor.setSelectedBufferRange(editor.bufferRangeForScreenRange(_this.misspellingRange));
          return editor.insertText(correction);
        };
      })(this));
      return this.editorView.focus();
    };

    CorrectionsView.prototype.attach = function() {
      this.aboveCursor = false;
      this.setItems(this.corrections);
      this.editorView.appendToLinesView(this);
      this.setPosition();
      return this.focusFilterEditor();
    };

    CorrectionsView.prototype.getEmptyMessage = function(itemCount) {
      if (itemCount === 0) {
        return 'No corrections';
      } else {
        return CorrectionsView.__super__.getEmptyMessage.apply(this, arguments);
      }
    };

    CorrectionsView.prototype.setPosition = function() {
      var height, left, potentialBottom, potentialTop, top, _ref1;
      _ref1 = this.editorView.pixelPositionForScreenPosition(this.misspellingRange.start), left = _ref1.left, top = _ref1.top;
      height = this.outerHeight();
      potentialTop = top + this.editorView.lineHeight;
      potentialBottom = potentialTop - this.editorView.scrollTop() + height;
      if (this.aboveCursor || potentialBottom > this.editorView.outerHeight()) {
        this.aboveCursor = true;
        return this.css({
          left: left,
          top: top - height,
          bottom: 'inherit'
        });
      } else {
        return this.css({
          left: left,
          top: potentialTop,
          bottom: 'inherit'
        });
      }
    };

    CorrectionsView.prototype.populateList = function() {
      CorrectionsView.__super__.populateList.apply(this, arguments);
      return this.setPosition();
    };

    return CorrectionsView;

  })(SelectListView);

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/spell-check/lib/corrections-view.js.map
