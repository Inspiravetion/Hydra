(function() {
  var CorrectionsView, MisspellingView, Range, View, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('atom'), Range = _ref.Range, View = _ref.View;

  CorrectionsView = require('./corrections-view');

  module.exports = MisspellingView = (function(_super) {
    __extends(MisspellingView, _super);

    function MisspellingView() {
      return MisspellingView.__super__.constructor.apply(this, arguments);
    }

    MisspellingView.content = function() {
      return this.div({
        "class": 'misspelling'
      });
    };

    MisspellingView.prototype.initialize = function(range, editorView) {
      this.editorView = editorView;
      this.editor = this.editorView.getEditor();
      this.misspellingValid = true;
      this.updateDisplayPosition = true;
      range = this.editor.screenRangeForBufferRange(Range.fromObject(range));
      this.startPosition = range.start;
      this.endPosition = range.end;
      this.oldScreenRange = this.getScreenRange();
      this.createMarker();
      this.subscribe(this.editorView, 'editor:display-updated', (function(_this) {
        return function() {
          if (_this.isUpdateNeeded()) {
            return _this.updatePosition();
          }
        };
      })(this));
      this.subscribeToCommand(this.editorView, 'spell-check:correct-misspelling', (function(_this) {
        return function() {
          var _ref1;
          if (_this.misspellingValid && _this.containsCursor()) {
            if ((_ref1 = _this.correctionsView) != null) {
              _ref1.remove();
            }
            return _this.correctionsView = new CorrectionsView(_this.editorView, _this.getCorrections(), _this.getScreenRange());
          }
        };
      })(this));
      if (this.isUpdateNeeded()) {
        return this.updatePosition();
      }
    };

    MisspellingView.prototype.createMarker = function() {
      this.marker = this.editor.markScreenRange(this.getScreenRange(), {
        invalidation: 'inside',
        replicate: false,
        persistent: false
      });
      return this.subscribe(this.marker, 'changed', (function(_this) {
        return function(_arg) {
          var isValid, newHeadScreenPosition, newTailScreenPosition;
          newHeadScreenPosition = _arg.newHeadScreenPosition, newTailScreenPosition = _arg.newTailScreenPosition, isValid = _arg.isValid;
          _this.startPosition = newTailScreenPosition;
          _this.endPosition = newHeadScreenPosition;
          _this.updateDisplayPosition = isValid;
          _this.misspellingValid = isValid;
          if (!isValid) {
            return _this.hide();
          }
        };
      })(this));
    };

    MisspellingView.prototype.isUpdateNeeded = function() {
      var newScreenRange, oldScreenRange;
      if (!this.updateDisplayPosition) {
        return false;
      }
      oldScreenRange = this.oldScreenRange;
      newScreenRange = this.getScreenRange();
      this.oldScreenRange = newScreenRange;
      return this.intersectsRenderedScreenRows(oldScreenRange) || this.intersectsRenderedScreenRows(newScreenRange);
    };

    MisspellingView.prototype.intersectsRenderedScreenRows = function(range) {
      return range.intersectsRowRange(this.editorView.firstRenderedScreenRow, this.editorView.lastRenderedScreenRow);
    };

    MisspellingView.prototype.getScreenRange = function() {
      return new Range(this.startPosition, this.endPosition);
    };

    MisspellingView.prototype.getCorrections = function() {
      var SpellChecker, corrections, misspelling, screenRange;
      screenRange = this.getScreenRange();
      misspelling = this.editor.getTextInRange(this.editor.bufferRangeForScreenRange(screenRange));
      SpellChecker = require('spellchecker');
      return corrections = SpellChecker.getCorrectionsForMisspelling(misspelling);
    };

    MisspellingView.prototype.beforeRemove = function() {
      return this.marker.destroy();
    };

    MisspellingView.prototype.containsCursor = function() {
      var cursor;
      cursor = this.editor.getCursorScreenPosition();
      return this.getScreenRange().containsPoint(cursor, {
        exclusive: false
      });
    };

    MisspellingView.prototype.updatePosition = function() {
      var endPixelPosition, startPixelPosition;
      this.updateDisplayPosition = false;
      startPixelPosition = this.editorView.pixelPositionForScreenPosition(this.startPosition);
      endPixelPosition = this.editorView.pixelPositionForScreenPosition(this.endPosition);
      this.css({
        top: startPixelPosition.top,
        left: startPixelPosition.left,
        width: endPixelPosition.left - startPixelPosition.left,
        height: this.editorView.lineHeight
      });
      return this.show();
    };

    MisspellingView.prototype.destroy = function() {
      var _ref1;
      this.misspellingValid = false;
      if ((_ref1 = this.correctionsView) != null) {
        _ref1.remove();
      }
      return this.remove();
    };

    return MisspellingView;

  })(View);

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/spell-check/lib/misspelling-view.js.map
