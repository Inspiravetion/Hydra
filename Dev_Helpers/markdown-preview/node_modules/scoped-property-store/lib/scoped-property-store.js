(function() {
  var PropertySet, ScopedPropertyStore, Selector, slick;

  slick = require('slick');

  Selector = require('./selector');

  PropertySet = require('./property-set');

  module.exports = ScopedPropertyStore = (function() {
    function ScopedPropertyStore() {
      this.propertySets = [];
      this.escapeCharacterRegex = /[-!"#$%&'*+,/:;=?@|^~()<>{}[\]]/g;
    }

    ScopedPropertyStore.prototype.addProperties = function(source, propertiesBySelector) {
      var properties, selector, selectorSource, _results;
      _results = [];
      for (selectorSource in propertiesBySelector) {
        properties = propertiesBySelector[selectorSource];
        _results.push((function() {
          var _i, _len, _ref, _results1;
          _ref = Selector.create(selectorSource);
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            selector = _ref[_i];
            _results1.push(this.propertySets.push(new PropertySet(source, selector, properties)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ScopedPropertyStore.prototype.removeProperties = function(source) {
      return this.propertySets = this.propertySets.filter(function(set) {
        return set.source !== source;
      });
    };

    ScopedPropertyStore.prototype.getPropertyValue = function(scopeChain, keyPath) {
      var candidateSets, matchingSets;
      candidateSets = this.propertySets.filter(function(set) {
        return set.has(keyPath);
      });
      if (!(candidateSets.length > 0)) {
        return;
      }
      scopeChain = this.parseScopeChain(scopeChain);
      while (scopeChain.length > 0) {
        matchingSets = candidateSets.filter(function(set) {
          return set.matches(scopeChain);
        }).sort(function(a, b) {
          return a.compare(b);
        });
        if (matchingSets.length > 0) {
          return matchingSets[0].get(keyPath);
        } else {
          scopeChain.pop();
        }
      }
      return void 0;
    };

    ScopedPropertyStore.prototype.getProperties = function(scopeChain, keyPath) {
      var candidateSets, matchingSets, values;
      values = [];
      candidateSets = this.propertySets;
      if (keyPath != null) {
        candidateSets = this.propertySets.filter(function(set) {
          return set.has(keyPath);
        });
      }
      if (!(candidateSets.length > 0)) {
        return values;
      }
      scopeChain = this.parseScopeChain(scopeChain);
      while (scopeChain.length > 0) {
        matchingSets = candidateSets.filter(function(set) {
          return set.matches(scopeChain);
        }).sort(function(a, b) {
          return a.compare(b);
        });
        values.push.apply(values, matchingSets.map(function(set) {
          return set.properties;
        }));
        scopeChain.pop();
      }
      return values;
    };

    ScopedPropertyStore.prototype.parseScopeChain = function(scopeChain) {
      var scope, _i, _len, _ref, _results;
      scopeChain = scopeChain.replace(this.escapeCharacterRegex, function(match) {
        return "\\" + match[0];
      });
      _ref = slick.parse(scopeChain)[0];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scope = _ref[_i];
        _results.push(scope);
      }
      return _results;
    };

    return ScopedPropertyStore;

  })();

}).call(this);
