(function() {
  var $, CommandPalette, WorkspaceView, _, _ref;

  _ = require('underscore-plus');

  _ref = require('atom'), $ = _ref.$, WorkspaceView = _ref.WorkspaceView;

  CommandPalette = require('../lib/command-palette-view');

  describe("CommandPalette", function() {
    var palette;
    palette = [][0];
    beforeEach(function() {
      var activationPromise;
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.openSync('sample.js');
      activationPromise = atom.packages.activatePackage("command-palette");
      atom.workspaceView.attachToDom().focus();
      atom.workspaceView.trigger('command-palette:toggle');
      waitsForPromise(function() {
        return activationPromise;
      });
      return runs(function() {
        return palette = atom.workspaceView.find('.command-palette').view();
      });
    });
    afterEach(function() {
      return atom.workspaceView.remove();
    });
    describe("when command-palette:toggle is triggered on the root view", function() {
      it("shows a list of all valid command descriptions, names, and keybindings for the previously focused element", function() {
        var binding, description, eventLi, eventName, keyBindings, _ref1, _results;
        keyBindings = atom.keymap.keyBindingsMatchingElement(atom.workspaceView.getActiveView());
        _ref1 = atom.workspaceView.getActiveView().events();
        _results = [];
        for (eventName in _ref1) {
          description = _ref1[eventName];
          eventLi = palette.find("[data-event-name='" + eventName + "']");
          if (description) {
            expect(eventLi).toExist();
            expect(eventLi.find('span')).toHaveText(description);
            expect(eventLi.find('span').attr('title')).toBe(eventName);
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = keyBindings.length; _i < _len; _i++) {
                binding = keyBindings[_i];
                if (binding.command === eventName) {
                  _results1.push(expect(eventLi.find(".key-binding:contains(" + (_.humanizeKeystroke(binding.keystroke)) + ")")).toExist());
                }
              }
              return _results1;
            })());
          } else {
            _results.push(expect(eventLi).not.toExist());
          }
        }
        return _results;
      });
      it("displays all commands registerd on the window", function() {
        var description, editorEvents, eventLi, eventName, windowEvents, _results;
        editorEvents = atom.workspaceView.getActiveView().events();
        windowEvents = $(window).events();
        expect(_.isEmpty(windowEvents)).toBeFalsy();
        _results = [];
        for (eventName in windowEvents) {
          description = windowEvents[eventName];
          eventLi = palette.list.children("[data-event-name='" + eventName + "']");
          if (!description) {
            description = editorEvents[eventName];
          }
          if (description) {
            expect(eventLi).toExist();
            expect(eventLi.find('span')).toHaveText(description);
            _results.push(expect(eventLi.find('span').attr('title')).toBe(eventName));
          } else {
            _results.push(expect(eventLi).not.toExist());
          }
        }
        return _results;
      });
      it("focuses the mini-editor and selects the first command", function() {
        expect(palette.filterEditorView.isFocused).toBeTruthy();
        return expect(palette.find('.event:first')).toHaveClass('selected');
      });
      return it("clears the previous mini editor text", function() {
        palette.filterEditorView.setText('hello');
        palette.trigger('command-palette:toggle');
        atom.workspaceView.trigger('command-palette:toggle');
        return expect(palette.filterEditorView.getText()).toBe('');
      });
    });
    describe("when command-palette:toggle is triggered on the open command palette", function() {
      return it("focus the root view and detaches the command palette", function() {
        expect(palette.hasParent()).toBeTruthy();
        palette.trigger('command-palette:toggle');
        expect(palette.hasParent()).toBeFalsy();
        return expect(atom.workspaceView.getActiveView().isFocused).toBeTruthy();
      });
    });
    describe("when the command palette is cancelled", function() {
      return it("focuses the root view and detaches the command palette", function() {
        expect(palette.hasParent()).toBeTruthy();
        palette.cancel();
        expect(palette.hasParent()).toBeFalsy();
        return expect(atom.workspaceView.getActiveView().isFocused).toBeTruthy();
      });
    });
    describe("when an command selection is confirmed", function() {
      return it("detaches the palette, then focuses the previously focused element and emits the selected command on it", function() {
        var activeEditor, eventHandler, eventName;
        eventHandler = jasmine.createSpy('eventHandler');
        activeEditor = atom.workspaceView.getActiveView();
        eventName = palette.items[5].eventName;
        activeEditor.preempt(eventName, eventHandler);
        palette.confirmed(palette.items[5]);
        expect(activeEditor.isFocused).toBeTruthy();
        expect(eventHandler).toHaveBeenCalled();
        return expect(palette.hasParent()).toBeFalsy();
      });
    });
    describe("when no element has focus", function() {
      return it("uses the root view as the element to display and trigger events for", function() {
        var binding, description, eventLi, eventName, keyBindings, _ref1, _results;
        atom.workspaceView.trigger('command-palette:toggle');
        $(':focus').blur();
        atom.workspaceView.trigger('command-palette:toggle');
        keyBindings = atom.keymap.keyBindingsMatchingElement(atom.workspaceView.getActiveView());
        _ref1 = atom.workspaceView.events();
        _results = [];
        for (eventName in _ref1) {
          description = _ref1[eventName];
          eventLi = palette.list.children("[data-event-name='" + eventName + "']");
          if (description) {
            expect(eventLi).toExist();
            expect(eventLi.find('span')).toHaveText(description);
            expect(eventLi.find('span').attr('title')).toBe(eventName);
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = keyBindings.length; _i < _len; _i++) {
                binding = keyBindings[_i];
                if (binding.command === eventName) {
                  _results1.push(expect(eventLi.find(".key-binding:contains(" + (_.humanizeKeystroke(binding.keystroke)) + ")")).toExist());
                }
              }
              return _results1;
            })());
          } else {
            _results.push(expect(eventLi).not.toExist());
          }
        }
        return _results;
      });
    });
    return describe("when the body has focus", function() {
      return it("uses the root view as the element to display and trigger events for", function() {
        var binding, description, eventLi, eventName, keyBindings, _ref1, _results;
        atom.workspaceView.trigger('command-palette:toggle');
        $(document.body).focus();
        atom.workspaceView.trigger('command-palette:toggle');
        keyBindings = atom.keymap.keyBindingsMatchingElement(atom.workspaceView.getActiveView());
        _ref1 = atom.workspaceView.events();
        _results = [];
        for (eventName in _ref1) {
          description = _ref1[eventName];
          eventLi = palette.list.children("[data-event-name='" + eventName + "']");
          if (description) {
            expect(eventLi).toExist();
            expect(eventLi.find('span')).toHaveText(description);
            expect(eventLi.find('span').attr('title')).toBe(eventName);
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = keyBindings.length; _i < _len; _i++) {
                binding = keyBindings[_i];
                if (binding.command === eventName) {
                  _results1.push(expect(eventLi.find(".key-binding:contains(" + (_.humanizeKeystroke(binding.keystroke)) + ")")).toExist());
                }
              }
              return _results1;
            })());
          } else {
            _results.push(expect(eventLi).not.toExist());
          }
        }
        return _results;
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/command-palette/spec/command-palette-spec.js.map
