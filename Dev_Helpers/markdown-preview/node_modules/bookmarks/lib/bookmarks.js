(function() {
  var Bookmarks, Subscriber, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore-plus');

  Subscriber = require('emissary').Subscriber;

  module.exports = Bookmarks = (function() {
    Subscriber.includeInto(Bookmarks);

    function Bookmarks(editorView) {
      this.jumpToBookmark = __bind(this.jumpToBookmark, this);
      this.renderBookmarkMarkers = __bind(this.renderBookmarkMarkers, this);
      this.jumpToPreviousBookmark = __bind(this.jumpToPreviousBookmark, this);
      this.jumpToNextBookmark = __bind(this.jumpToNextBookmark, this);
      this.clearBookmarks = __bind(this.clearBookmarks, this);
      this.toggleBookmark = __bind(this.toggleBookmark, this);
      this.editor = editorView.editor, this.gutter = editorView.gutter;
      this.subscribe(editorView, 'editor:display-updated', this.renderBookmarkMarkers);
      this.subscribe(this.editor.getBuffer(), 'bookmarks:created bookmarks:destroyed', this.renderBookmarkMarkers);
      this.subscribe(this.editor, 'destroyed', (function(_this) {
        return function() {
          return _this.unsubscribe();
        };
      })(this));
      this.subscribeToCommand(editorView, 'bookmarks:toggle-bookmark', this.toggleBookmark);
      this.subscribeToCommand(editorView, 'bookmarks:jump-to-next-bookmark', this.jumpToNextBookmark);
      this.subscribeToCommand(editorView, 'bookmarks:jump-to-previous-bookmark', this.jumpToPreviousBookmark);
      this.subscribeToCommand(editorView, 'bookmarks:clear-bookmarks', this.clearBookmarks);
    }

    Bookmarks.prototype.toggleBookmark = function() {
      var bookmark, bookmarks, cursor, cursors, position, _i, _j, _len, _len1;
      cursors = this.editor.getCursors();
      for (_i = 0, _len = cursors.length; _i < _len; _i++) {
        cursor = cursors[_i];
        position = cursor.getBufferPosition();
        bookmarks = this.findBookmarkMarkers({
          startBufferRow: position.row
        });
        if ((bookmarks != null ? bookmarks.length : void 0) > 0) {
          for (_j = 0, _len1 = bookmarks.length; _j < _len1; _j++) {
            bookmark = bookmarks[_j];
            bookmark.destroy();
          }
          this.editor.getBuffer().emit('bookmarks:destroyed');
        } else {
          this.createBookmarkMarker(position.row);
          this.editor.getBuffer().emit('bookmarks:created');
        }
      }
      return this.renderBookmarkMarkers();
    };

    Bookmarks.prototype.clearBookmarks = function() {
      var bookmark, _i, _len, _ref;
      _ref = this.findBookmarkMarkers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bookmark = _ref[_i];
        bookmark.destroy();
      }
      return this.renderBookmarkMarkers();
    };

    Bookmarks.prototype.jumpToNextBookmark = function() {
      return this.jumpToBookmark('getNextBookmark');
    };

    Bookmarks.prototype.jumpToPreviousBookmark = function() {
      return this.jumpToBookmark('getPreviousBookmark');
    };

    Bookmarks.prototype.renderBookmarkMarkers = function() {
      var marker, markers, row, _i, _len;
      if (!this.gutter.isVisible()) {
        return;
      }
      this.gutter.removeClassFromAllLines('bookmarked');
      markers = this.findBookmarkMarkers();
      for (_i = 0, _len = markers.length; _i < _len; _i++) {
        marker = markers[_i];
        if (!(marker.isValid())) {
          continue;
        }
        row = marker.getBufferRange().start.row;
        this.gutter.addClassToLine(row, 'bookmarked');
      }
      return null;
    };

    Bookmarks.prototype.jumpToBookmark = function(getBookmarkFunction) {
      var bookmarkMarker, cursor, position;
      cursor = this.editor.getCursor();
      position = cursor.getBufferPosition();
      bookmarkMarker = this[getBookmarkFunction](position.row);
      if (bookmarkMarker) {
        return this.editor.setSelectedBufferRange(bookmarkMarker.getBufferRange(), {
          autoscroll: true
        });
      } else {
        return atom.beep();
      }
    };

    Bookmarks.prototype.getPreviousBookmark = function(bufferRow) {
      var bookmarkIndex, markers;
      markers = this.findBookmarkMarkers();
      if (!markers.length) {
        return null;
      }
      if (markers.length === 1) {
        return markers[0];
      }
      bookmarkIndex = _.sortedIndex(markers, bufferRow, function(marker) {
        if (marker.getBufferRange) {
          return marker.getBufferRange().start.row;
        } else {
          return marker;
        }
      });
      bookmarkIndex--;
      if (bookmarkIndex < 0) {
        bookmarkIndex = markers.length - 1;
      }
      return markers[bookmarkIndex];
    };

    Bookmarks.prototype.getNextBookmark = function(bufferRow) {
      var bookmarkIndex, markers;
      markers = this.findBookmarkMarkers();
      if (!markers.length) {
        return null;
      }
      if (markers.length === 1) {
        return markers[0];
      }
      bookmarkIndex = _.sortedIndex(markers, bufferRow, function(marker) {
        if (marker.getBufferRange) {
          return marker.getBufferRange().start.row;
        } else {
          return marker;
        }
      });
      if (markers[bookmarkIndex] && markers[bookmarkIndex].getBufferRange().start.row === bufferRow) {
        bookmarkIndex++;
      }
      if (bookmarkIndex >= markers.length) {
        bookmarkIndex = 0;
      }
      return markers[bookmarkIndex];
    };

    Bookmarks.prototype.createBookmarkMarker = function(bufferRow) {
      var bookmark, range;
      range = [[bufferRow, 0], [bufferRow, 0]];
      bookmark = this.displayBuffer().markBufferRange(range, this.bookmarkMarkerAttributes({
        invalidate: 'surround'
      }));
      this.subscribe(bookmark, 'changed', function(_arg) {
        var isValid;
        isValid = _arg.isValid;
        if (!isValid) {
          return bookmark.destroy();
        }
      });
      return bookmark;
    };

    Bookmarks.prototype.findBookmarkMarkers = function(attributes) {
      if (attributes == null) {
        attributes = {};
      }
      return this.displayBuffer().findMarkers(this.bookmarkMarkerAttributes(attributes));
    };

    Bookmarks.prototype.bookmarkMarkerAttributes = function(attributes) {
      if (attributes == null) {
        attributes = {};
      }
      return _.extend(attributes, {
        "class": 'bookmark'
      });
    };

    Bookmarks.prototype.displayBuffer = function() {
      return this.editor.displayBuffer;
    };

    return Bookmarks;

  })();

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/bookmarks/lib/bookmarks.js.map
