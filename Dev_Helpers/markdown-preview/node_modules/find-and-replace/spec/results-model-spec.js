(function() {
  var $, ResultsModel, WorkspaceView, path, waitsForPromise, _ref;

  path = require('path');

  _ref = require('atom'), $ = _ref.$, WorkspaceView = _ref.WorkspaceView;

  ResultsModel = require('../lib/project/results-model.coffee');

  waitsForPromise = function(fn) {
    return window.waitsForPromise({
      timeout: 30000
    }, fn);
  };

  describe('ResultsModel', function() {
    var editSession, resultsModel, searchPromise, _ref1;
    _ref1 = [], editSession = _ref1[0], searchPromise = _ref1[1], resultsModel = _ref1[2], searchPromise = _ref1[3];
    beforeEach(function() {
      var editor;
      atom.workspaceView = new WorkspaceView();
      atom.project.setPath(path.join(__dirname, 'fixtures'));
      atom.workspaceView.openSync('sample.js');
      atom.workspaceView.attachToDom();
      editor = atom.workspaceView.getActiveView();
      editSession = editor.editor;
      return resultsModel = new ResultsModel();
    });
    describe("searching for a pattern", function() {
      beforeEach(function() {});
      it("populates the model with all the results, and updates in response to changes in the buffer", function() {
        var resultAddedSpy, resultRemovedSpy;
        resultAddedSpy = jasmine.createSpy();
        resultRemovedSpy = jasmine.createSpy();
        runs(function() {
          resultsModel.on('result-added', resultAddedSpy);
          resultsModel.on('result-removed', resultRemovedSpy);
          return searchPromise = resultsModel.search('items', ['*.js'], '');
        });
        waitsForPromise(function() {
          return searchPromise;
        });
        return runs(function() {
          var result;
          expect(resultAddedSpy).toHaveBeenCalled();
          expect(resultAddedSpy.callCount).toBe(1);
          result = resultsModel.getResult(editSession.getPath());
          expect(result.matches.length).toBe(6);
          expect(resultsModel.getPathCount()).toBe(1);
          expect(resultsModel.getMatchCount()).toBe(6);
          expect(resultsModel.getPaths()).toEqual([editSession.getPath()]);
          editSession.setText('there are some items in here');
          editSession.buffer.emit('contents-modified');
          expect(resultAddedSpy.callCount).toBe(2);
          result = resultsModel.getResult(editSession.getPath());
          expect(result.matches.length).toBe(1);
          expect(resultsModel.getPathCount()).toBe(1);
          expect(resultsModel.getMatchCount()).toBe(1);
          expect(resultsModel.getPaths()).toEqual([editSession.getPath()]);
          expect(result.matches[0].lineText).toBe('there are some items in here');
          editSession.setText('no matches in here');
          editSession.buffer.emit('contents-modified');
          expect(resultAddedSpy.callCount).toBe(2);
          expect(resultRemovedSpy.callCount).toBe(1);
          result = resultsModel.getResult(editSession.getPath());
          expect(result).not.toBeDefined();
          expect(resultsModel.getPathCount()).toBe(0);
          expect(resultsModel.getMatchCount()).toBe(0);
          resultsModel.clear();
          spyOn(editSession, 'scan').andCallThrough();
          editSession.setText('no matches in here');
          editSession.buffer.emit('contents-modified');
          expect(editSession.scan).not.toHaveBeenCalled();
          expect(resultsModel.getPathCount()).toBe(0);
          return expect(resultsModel.getMatchCount()).toBe(0);
        });
      });
      return it("ignores changes in untitled buffers", function() {
        var resultAddedSpy, resultRemovedSpy;
        resultAddedSpy = jasmine.createSpy();
        resultRemovedSpy = jasmine.createSpy();
        waitsForPromise(function() {
          return atom.workspaceView.open();
        });
        runs(function() {
          resultsModel.on('result-added', resultAddedSpy);
          resultsModel.on('result-removed', resultRemovedSpy);
          return searchPromise = resultsModel.search('items', ['*.js'], '');
        });
        waitsForPromise(function() {
          return searchPromise;
        });
        return runs(function() {
          editSession = atom.workspaceView.getActiveView().editor;
          editSession.setText('items\nitems');
          spyOn(editSession, 'scan').andCallThrough();
          editSession.buffer.emit('contents-modified');
          return expect(editSession.scan).not.toHaveBeenCalled();
        });
      });
    });
    return describe("cancelling a search", function() {
      var cancelledSpy;
      cancelledSpy = null;
      beforeEach(function() {
        cancelledSpy = jasmine.createSpy();
        return resultsModel.on('cancelled-searching', cancelledSpy);
      });
      it("populates the model with all the results, and updates in response to changes in the buffer", function() {
        runs(function() {
          searchPromise = resultsModel.search('items', ['*.js'], '');
          expect(resultsModel.inProgressSearchPromise).toBeTruthy();
          resultsModel.clear();
          return expect(resultsModel.inProgressSearchPromise).toBeFalsy();
        });
        waitsForPromise(function() {
          return searchPromise;
        });
        return runs(function() {
          return expect(cancelledSpy).toHaveBeenCalled();
        });
      });
      return it("populates the model with all the results, and updates in response to changes in the buffer", function() {
        runs(function() {
          searchPromise = resultsModel.search('items', ['*.js'], '');
          return searchPromise = resultsModel.search('sort', ['*.js'], '');
        });
        waitsForPromise(function() {
          return searchPromise;
        });
        return runs(function() {
          expect(cancelledSpy).toHaveBeenCalled();
          expect(resultsModel.getPathCount()).toBe(1);
          return expect(resultsModel.getMatchCount()).toBe(5);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/find-and-replace/spec/results-model-spec.js.map
