(function() {
  var $, Q, ResultsPaneView, View, WorkspaceView, fs, os, path, temp, waitsForPromise, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  os = require('os');

  path = require('path');

  temp = require('temp');

  _ = require('underscore-plus');

  _ref = require('atom'), $ = _ref.$, View = _ref.View, WorkspaceView = _ref.WorkspaceView;

  fs = require('fs-plus');

  Q = require('q');

  ResultsPaneView = require('../lib/project/results-pane');

  waitsForPromise = function(fn) {
    return window.waitsForPromise({
      timeout: 30000
    }, fn);
  };

  describe('ProjectFindView', function() {
    var activationPromise, editorView, getExistingResultsPane, projectFindView, resultsPane, searchPromise, _ref1;
    _ref1 = [], activationPromise = _ref1[0], editorView = _ref1[1], projectFindView = _ref1[2], searchPromise = _ref1[3], resultsPane = _ref1[4];
    getExistingResultsPane = function() {
      var pane;
      pane = atom.workspaceView.panes.paneForUri(ResultsPaneView.URI);
      if (pane != null) {
        return pane.itemForUri(ResultsPaneView.URI);
      }
      return null;
    };
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView();
      atom.project.setPath(path.join(__dirname, 'fixtures'));
      atom.workspaceView.attachToDom();
      atom.config.set('find-and-replace.openProjectFindResultsInRightPane', false);
      return activationPromise = atom.packages.activatePackage("find-and-replace").then(function(_arg) {
        var mainModule, spy;
        mainModule = _arg.mainModule;
        mainModule.createProjectFindView();
        projectFindView = mainModule.projectFindView;
        return spy = spyOn(projectFindView, 'confirm').andCallFake(function() {
          searchPromise = spy.originalValue.call(projectFindView);
          resultsPane = atom.workspaceView.find('.preview-pane').view();
          return searchPromise;
        });
      });
    });
    describe("when project-find:show is triggered", function() {
      beforeEach(function() {
        atom.workspaceView.trigger('project-find:show');
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          return projectFindView.findEditor.setText('items');
        });
      });
      it("attaches ProjectFindView to the root view", function() {
        expect(atom.workspaceView.find('.project-find')).toExist();
        expect(projectFindView.find('.preview-block')).not.toBeVisible();
        expect(projectFindView.find('.loading')).not.toBeVisible();
        return expect(projectFindView.findEditor.getEditor().getSelectedBufferRange()).toEqual([[0, 0], [0, 5]]);
      });
      describe("with an open buffer", function() {
        var editor;
        editor = null;
        beforeEach(function() {
          projectFindView.findEditor.setText('');
          return editor = atom.workspaceView.openSync('sample.js');
        });
        return it("populates the findEditor with selection when there is a selection", function() {
          editor.setSelectedBufferRange([[2, 8], [2, 13]]);
          atom.workspaceView.trigger('project-find:show');
          expect(atom.workspaceView.find('.project-find')).toExist();
          expect(projectFindView.findEditor.getText()).toBe('items');
          projectFindView.findEditor.setText('');
          editor.setSelectedBufferRange([[2, 14], [2, 20]]);
          atom.workspaceView.trigger('project-find:show');
          expect(atom.workspaceView.find('.project-find')).toExist();
          return expect(projectFindView.findEditor.getText()).toBe('length');
        });
      });
      return describe("when thethe ProjectFindView is already attached", function() {
        beforeEach(function() {
          return projectFindView.findEditor.getEditor().setSelectedBufferRange([[0, 0], [0, 0]]);
        });
        return it("focuses the find editor and selects all the text", function() {
          atom.workspaceView.trigger('project-find:show');
          expect(projectFindView.findEditor).toHaveFocus();
          return expect(projectFindView.findEditor.getEditor().getSelectedText()).toBe("items");
        });
      });
    });
    describe("when project-find:show-in-current-directory is triggered", function() {
      var DirElement, FileElement, nested, tree, _ref2;
      _ref2 = [], nested = _ref2[0], tree = _ref2[1];
      DirElement = (function(_super) {
        __extends(DirElement, _super);

        function DirElement() {
          return DirElement.__super__.constructor.apply(this, arguments);
        }

        DirElement.content = function(path) {
          return this.div({
            "class": 'directory'
          }, (function(_this) {
            return function() {
              return _this.div({
                "class": 'nested-thing'
              }, function() {
                _this.span({
                  outlet: 'name',
                  "class": 'name'
                }, path);
                return _this.ul({
                  outlet: 'files',
                  "class": 'files'
                });
              });
            };
          })(this));
        };

        DirElement.prototype.initialize = function(path) {
          this.path = path;
        };

        DirElement.prototype.getPath = function() {
          return this.path;
        };

        DirElement.prototype.createFiles = function(names) {
          var name, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            _results.push(this.files.append(new FileElement(path.join(this.path, name))));
          }
          return _results;
        };

        return DirElement;

      })(View);
      FileElement = (function(_super) {
        __extends(FileElement, _super);

        function FileElement() {
          return FileElement.__super__.constructor.apply(this, arguments);
        }

        FileElement.content = function(path) {
          return this.li({
            "class": 'file'
          }, (function(_this) {
            return function() {
              return _this.span({
                outlet: 'name',
                "class": 'name'
              }, path);
            };
          })(this));
        };

        FileElement.prototype.initialize = function(path) {
          this.path = path;
        };

        FileElement.prototype.getPath = function() {
          return this.path;
        };

        return FileElement;

      })(View);
      beforeEach(function() {
        var p;
        p = atom.project.getPath();
        tree = new DirElement(p);
        tree.createFiles(['one.js', 'two.js']);
        nested = new DirElement(path.join(p, 'nested'));
        nested.createFiles([path.join('nested', 'another.js')]);
        tree.files.append(nested);
        return atom.workspaceView.append(tree);
      });
      it("populates the pathsEditor when triggered with a directory", function() {
        nested.name.trigger('project-find:show-in-current-directory');
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          expect(atom.workspaceView.find('.project-find')).toExist();
          expect(projectFindView.pathsEditor.getText()).toBe('nested');
          tree.name.trigger('project-find:show-in-current-directory');
          return expect(projectFindView.pathsEditor.getText()).toBe('');
        });
      });
      return it("populates the pathsEditor when triggered with a file", function() {
        nested.files.find('> .file:eq(0)').view().name.trigger('project-find:show-in-current-directory');
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          expect(atom.workspaceView.find('.project-find')).toExist();
          expect(projectFindView.pathsEditor.getText()).toBe('nested');
          tree.files.find('> .file:eq(0)').view().name.trigger('project-find:show-in-current-directory');
          return expect(projectFindView.pathsEditor.getText()).toBe('');
        });
      });
    });
    describe("finding", function() {
      beforeEach(function() {
        atom.workspaceView.openSync('sample.js');
        editorView = atom.workspaceView.getActiveView();
        atom.workspaceView.trigger('project-find:show');
        return waitsForPromise(function() {
          return activationPromise;
        });
      });
      describe("when the find string contains an escaped char", function() {
        beforeEach(function() {
          var projectPath;
          projectPath = temp.mkdirSync("atom");
          fs.writeFileSync(path.join(projectPath, "tabs.txt"), "\t\n\\\t\n\\\\t");
          atom.project.setPath(projectPath);
          return atom.workspaceView.trigger('project-find:show');
        });
        it("finds the escape char", function() {
          projectFindView.findEditor.setText('\\t');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            var resultsPaneView, resultsView;
            resultsPaneView = getExistingResultsPane();
            resultsView = resultsPaneView.resultsView;
            expect(resultsView).toBeVisible();
            return expect(resultsView.find("li > ul > li")).toHaveLength(2);
          });
        });
        return it("doesn't insert a escaped char if there are multiple backslashs in front of the char", function() {
          projectFindView.findEditor.setText('\\\\t');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            var resultsPaneView, resultsView;
            resultsPaneView = getExistingResultsPane();
            resultsView = resultsPaneView.resultsView;
            expect(resultsView).toBeVisible();
            return expect(resultsView.find("li > ul > li")).toHaveLength(1);
          });
        });
      });
      describe("when core:cancel is triggered", function() {
        beforeEach(function() {
          atom.workspaceView.trigger('project-find:show');
          return projectFindView.focus();
        });
        return it("detaches from the root view", function() {
          $(document.activeElement).trigger('core:cancel');
          return expect(atom.workspaceView.find('.project-find')).not.toExist();
        });
      });
      describe("splitting into a second pane", function() {
        beforeEach(function() {
          atom.workspaceView.height(1000);
          return editorView.trigger('project-find:show');
        });
        it("splits when option is true", function() {
          var initialPane;
          initialPane = atom.workspaceView.getActivePane();
          atom.config.set('find-and-replace.openProjectFindResultsInRightPane', true);
          projectFindView.findEditor.setText('items');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            var pane1;
            pane1 = atom.workspaceView.getActivePane();
            return expect(pane1[0]).not.toBe(initialPane[0]);
          });
        });
        it("does not split when option is false", function() {
          var initialPane;
          initialPane = atom.workspaceView.getActivePane();
          projectFindView.findEditor.setText('items');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            var pane1;
            pane1 = atom.workspaceView.getActivePane();
            return expect(pane1[0]).toBe(initialPane[0]);
          });
        });
        return it("can be duplicated", function() {
          atom.config.set('find-and-replace.openProjectFindResultsInRightPane', true);
          projectFindView.findEditor.setText('items');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            var length, pane1, pane2, resultsPaneView1, resultsPaneView2;
            resultsPaneView1 = getExistingResultsPane();
            pane1 = atom.workspaceView.getActivePane();
            pane1.splitRight(pane1.copyActiveItem());
            pane2 = atom.workspaceView.getActivePane();
            resultsPaneView2 = pane2.itemForUri(ResultsPaneView.URI);
            expect(pane1[0]).not.toBe(pane2[0]);
            expect(resultsPaneView1[0]).not.toBe(resultsPaneView2[0]);
            length = resultsPaneView1.find('li > ul > li').length;
            expect(length).toBeGreaterThan(0);
            expect(resultsPaneView2.find('li > ul > li')).toHaveLength(length);
            return expect(resultsPaneView2.previewCount.html()).toEqual(resultsPaneView1.previewCount.html());
          });
        });
      });
      describe("serialization", function() {
        return it("serializes if the case and regex options", function() {
          editorView.trigger('project-find:show');
          expect(projectFindView.caseOptionButton).not.toHaveClass('selected');
          projectFindView.caseOptionButton.click();
          expect(projectFindView.caseOptionButton).toHaveClass('selected');
          expect(projectFindView.regexOptionButton).not.toHaveClass('selected');
          projectFindView.regexOptionButton.click();
          expect(projectFindView.regexOptionButton).toHaveClass('selected');
          atom.packages.deactivatePackage("find-and-replace");
          activationPromise = atom.packages.activatePackage("find-and-replace").then(function(_arg) {
            var mainModule;
            mainModule = _arg.mainModule;
            mainModule.createProjectFindView();
            return projectFindView = mainModule.projectFindView, mainModule;
          });
          editorView.trigger('project-find:show');
          waitsForPromise(function() {
            return activationPromise;
          });
          return runs(function() {
            expect(projectFindView.caseOptionButton).toHaveClass('selected');
            return expect(projectFindView.regexOptionButton).toHaveClass('selected');
          });
        });
      });
      describe("regex", function() {
        beforeEach(function() {
          editorView.trigger('project-find:show');
          projectFindView.findEditor.setText('i(\\w)ems+');
          return spyOn(atom.project, 'scan').andCallFake(function() {
            return Q();
          });
        });
        it("escapes regex patterns by default", function() {
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            return expect(atom.project.scan.argsForCall[0][0]).toEqual(/i\(\\w\)ems\+/gi);
          });
        });
        it("shows an error when the regex pattern is invalid", function() {
          projectFindView.trigger('project-find:toggle-regex-option');
          projectFindView.findEditor.setText('[');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            return expect(projectFindView.errorMessages).toBeVisible();
          });
        });
        describe("when search has not been run yet", function() {
          return it("toggles regex option via an event but does not run the search", function() {
            expect(projectFindView.regexOptionButton).not.toHaveClass('selected');
            projectFindView.trigger('project-find:toggle-regex-option');
            expect(projectFindView.regexOptionButton).toHaveClass('selected');
            return expect(atom.project.scan).not.toHaveBeenCalled();
          });
        });
        return describe("when search has been run", function() {
          beforeEach(function() {
            projectFindView.trigger('core:confirm');
            return waitsForPromise(function() {
              return searchPromise;
            });
          });
          it("toggles regex option via an event and finds files matching the pattern", function() {
            expect(projectFindView.regexOptionButton).not.toHaveClass('selected');
            projectFindView.trigger('project-find:toggle-regex-option');
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              expect(projectFindView.regexOptionButton).toHaveClass('selected');
              return expect(atom.project.scan.mostRecentCall.args[0]).toEqual(/i(\w)ems+/gi);
            });
          });
          return it("toggles regex option via a button and finds files matching the pattern", function() {
            expect(projectFindView.regexOptionButton).not.toHaveClass('selected');
            projectFindView.regexOptionButton.click();
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              expect(projectFindView.regexOptionButton).toHaveClass('selected');
              return expect(atom.project.scan.mostRecentCall.args[0]).toEqual(/i(\w)ems+/gi);
            });
          });
        });
      });
      describe("case sensitivity", function() {
        beforeEach(function() {
          editorView.trigger('project-find:show');
          spyOn(atom.project, 'scan').andCallFake(function() {
            return Q();
          });
          projectFindView.findEditor.setText('ITEMS');
          projectFindView.trigger('core:confirm');
          return waitsForPromise(function() {
            return searchPromise;
          });
        });
        it("runs a case insensitive search by default", function() {
          return expect(atom.project.scan.argsForCall[0][0]).toEqual(/ITEMS/gi);
        });
        it("toggles case sensitive option via an event and finds files matching the pattern", function() {
          expect(projectFindView.caseOptionButton).not.toHaveClass('selected');
          projectFindView.trigger('project-find:toggle-case-option');
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            expect(projectFindView.caseOptionButton).toHaveClass('selected');
            return expect(atom.project.scan.mostRecentCall.args[0]).toEqual(/ITEMS/g);
          });
        });
        return it("toggles case sensitive option via a button and finds files matching the pattern", function() {
          expect(projectFindView.caseOptionButton).not.toHaveClass('selected');
          projectFindView.caseOptionButton.click();
          waitsForPromise(function() {
            return searchPromise;
          });
          return runs(function() {
            expect(projectFindView.caseOptionButton).toHaveClass('selected');
            return expect(atom.project.scan.mostRecentCall.args[0]).toEqual(/ITEMS/g);
          });
        });
      });
      describe("when core:confirm is triggered", function() {
        beforeEach(function() {
          return atom.workspaceView.trigger('project-find:show');
        });
        describe("when the there search field is empty", function() {
          return it("does not run the seach but clears the model", function() {
            spyOn(atom.project, 'scan');
            spyOn(projectFindView.model, 'clear');
            projectFindView.trigger('core:confirm');
            expect(atom.project.scan).not.toHaveBeenCalled();
            return expect(projectFindView.model.clear).toHaveBeenCalled();
          });
        });
        describe("when results exist", function() {
          beforeEach(function() {
            return projectFindView.findEditor.setText('items');
          });
          it("displays the results and no errors", function() {
            projectFindView.trigger('core:confirm');
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              var resultsPaneView, resultsView;
              resultsPaneView = getExistingResultsPane();
              resultsView = resultsPaneView.resultsView;
              expect(resultsView).toBeVisible();
              resultsView.scrollToBottom();
              expect(resultsView.find("li > ul > li")).toHaveLength(13);
              expect(resultsPaneView.previewCount.text()).toBe("13 results found in 2 files for items");
              return expect(projectFindView.errorMessages).not.toBeVisible();
            });
          });
          it("only searches paths matching text in the path filter", function() {
            spyOn(atom.project, 'scan').andCallFake(function() {
              return Q();
            });
            projectFindView.pathsEditor.setText('*.js');
            projectFindView.trigger('core:confirm');
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              return expect(atom.project.scan.argsForCall[0][1]['paths']).toEqual(['*.js']);
            });
          });
          return it("updates the results list when a buffer changes", function() {
            var buffer;
            projectFindView.trigger('core:confirm');
            buffer = atom.project.bufferForPathSync('sample.js');
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              var resultsPaneView, resultsView;
              resultsPaneView = getExistingResultsPane();
              resultsView = resultsPaneView.resultsView;
              resultsView.scrollToBottom();
              expect(resultsView.find("li > ul > li")).toHaveLength(13);
              expect(resultsPaneView.previewCount.text()).toBe("13 results found in 2 files for items");
              resultsView.selectFirstResult();
              _.times(7, function() {
                return resultsView.selectNextResult();
              });
              expect(resultsView.find("li > ul:eq(1) > li:eq(0)")).toHaveClass('selected');
              buffer.setText('there is one "items" in this file');
              buffer.emit('contents-modified');
              expect(resultsView.find("li > ul > li")).toHaveLength(8);
              expect(resultsPaneView.previewCount.text()).toBe("8 results found in 2 files for items");
              expect(resultsView.find("li > ul:eq(1) > li:eq(0)")).toHaveClass('selected');
              buffer.setText('no matches in this file');
              buffer.emit('contents-modified');
              expect(resultsView.find("li > ul > li")).toHaveLength(7);
              return expect(resultsPaneView.previewCount.text()).toBe("7 results found in 1 file for items");
            });
          });
        });
        return describe("when no results exist", function() {
          beforeEach(function() {
            projectFindView.findEditor.setText('notintheprojectbro');
            return spyOn(atom.project, 'scan').andCallFake(function() {
              return Q();
            });
          });
          return it("displays no errors and no results", function() {
            projectFindView.trigger('core:confirm');
            waitsForPromise(function() {
              return searchPromise;
            });
            return runs(function() {
              var resultsView;
              resultsView = getExistingResultsPane().resultsView;
              expect(projectFindView.errorMessages).not.toBeVisible();
              expect(resultsView).toBeVisible();
              return expect(resultsView.find("li > ul > li")).toHaveLength(0);
            });
          });
        });
      });
      describe("history", function() {
        beforeEach(function() {
          atom.workspaceView.trigger('project-find:show');
          spyOn(atom.project, 'scan').andCallFake(function() {
            var promise;
            promise = Q();
            promise.cancel = function() {};
            return promise;
          });
          projectFindView.findEditor.setText('sort');
          projectFindView.replaceEditor.setText('bort');
          projectFindView.pathsEditor.setText('abc');
          projectFindView.findEditor.trigger('core:confirm');
          projectFindView.findEditor.setText('items');
          projectFindView.replaceEditor.setText('eyetims');
          projectFindView.pathsEditor.setText('def');
          return projectFindView.findEditor.trigger('core:confirm');
        });
        return it("can navigate the entire history stack", function() {
          expect(projectFindView.findEditor.getText()).toEqual('items');
          projectFindView.findEditor.trigger('core:move-up');
          expect(projectFindView.findEditor.getText()).toEqual('sort');
          projectFindView.findEditor.trigger('core:move-down');
          expect(projectFindView.findEditor.getText()).toEqual('items');
          projectFindView.findEditor.trigger('core:move-down');
          expect(projectFindView.findEditor.getText()).toEqual('');
          expect(projectFindView.pathsEditor.getText()).toEqual('def');
          projectFindView.pathsEditor.trigger('core:move-up');
          expect(projectFindView.pathsEditor.getText()).toEqual('abc');
          projectFindView.pathsEditor.trigger('core:move-down');
          expect(projectFindView.pathsEditor.getText()).toEqual('def');
          projectFindView.pathsEditor.trigger('core:move-down');
          expect(projectFindView.pathsEditor.getText()).toEqual('');
          expect(projectFindView.replaceEditor.getText()).toEqual('eyetims');
          projectFindView.replaceEditor.trigger('core:move-up');
          expect(projectFindView.replaceEditor.getText()).toEqual('bort');
          projectFindView.replaceEditor.trigger('core:move-down');
          expect(projectFindView.replaceEditor.getText()).toEqual('eyetims');
          projectFindView.replaceEditor.trigger('core:move-down');
          return expect(projectFindView.replaceEditor.getText()).toEqual('');
        });
      });
      return describe("when find-and-replace:set-find-pattern is triggered", function() {
        return it("places the selected text into the find editor", function() {
          editorView.getEditor().setSelectedBufferRange([[1, 6], [1, 10]]);
          atom.workspaceView.trigger('find-and-replace:use-selection-as-find-pattern');
          return expect(projectFindView.findEditor.getText()).toBe('sort');
        });
      });
    });
    return describe("replacing", function() {
      var replacePromise, sampleCoffee, sampleJs, testDir, _ref2;
      _ref2 = [], testDir = _ref2[0], sampleJs = _ref2[1], sampleCoffee = _ref2[2], replacePromise = _ref2[3];
      beforeEach(function() {
        testDir = path.join(os.tmpdir(), "atom-find-and-replace");
        fs.makeTreeSync(testDir);
        sampleJs = path.join(testDir, 'sample.js');
        sampleCoffee = path.join(testDir, 'sample.coffee');
        fs.writeFileSync(sampleCoffee, fs.readFileSync(require.resolve('./fixtures/sample.coffee')));
        fs.writeFileSync(sampleJs, fs.readFileSync(require.resolve('./fixtures/sample.js')));
        atom.workspaceView.trigger('project-find:show');
        waitsForPromise(function() {
          return activationPromise;
        });
        return runs(function() {
          var spy;
          atom.project.setPath(testDir);
          return spy = spyOn(projectFindView, 'replaceAll').andCallFake(function() {
            return replacePromise = spy.originalValue.call(projectFindView);
          });
        });
      });
      afterEach(function() {
        var activePane, item, success, _i, _len, _ref3;
        activePane = atom.workspaceView.getActivePane();
        _ref3 = (activePane != null ? activePane.getItems() : void 0) || [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          item = _ref3[_i];
          if (item.shouldPromptToSave != null) {
            spyOn(item, 'shouldPromptToSave').andReturn(false);
          }
          activePane.destroyItem(item);
        }
        success = false;
        runs(function() {
          var retry;
          return retry = setInterval(function() {
            var e;
            try {
              fs.removeSync(testDir);
              success = true;
              return clearInterval(retry);
            } catch (_error) {
              e = _error;
              return success = false;
            }
          }, 50);
        });
        return waitsFor(function() {
          return success;
        });
      });
      describe("when the replace string contains an escaped char", function() {
        var filePath;
        filePath = null;
        beforeEach(function() {
          var projectPath;
          projectPath = temp.mkdirSync("atom");
          filePath = path.join(projectPath, "tabs.txt");
          fs.writeFileSync(filePath, "a\nb\na");
          atom.project.setPath(projectPath);
          return atom.workspaceView.trigger('project-find:show');
        });
        it("finds the escape char", function() {
          projectFindView.findEditor.setText('a');
          projectFindView.replaceEditor.setText('\\t');
          projectFindView.trigger('project-find:replace-all');
          waitsForPromise(function() {
            return replacePromise;
          });
          return runs(function() {
            var fileContent;
            fileContent = fs.readFileSync(filePath, 'utf8');
            return expect(fileContent).toBe("\t\nb\n\t");
          });
        });
        return it("doesn't insert a escaped char if there are multiple backslashs in front of the char", function() {
          projectFindView.findEditor.setText('a');
          projectFindView.replaceEditor.setText('\\\\t');
          projectFindView.trigger('project-find:replace-all');
          waitsForPromise(function() {
            return replacePromise;
          });
          return runs(function() {
            var fileContent;
            fileContent = fs.readFileSync(filePath, 'utf8');
            return expect(fileContent).toBe("\\t\nb\n\\t");
          });
        });
      });
      describe("when the replace button is pressed", function() {
        it("runs the search, and replaces all the matches", function() {
          projectFindView.findEditor.setText('items');
          projectFindView.trigger('core:confirm');
          waitsForPromise(function() {
            return searchPromise;
          });
          runs(function() {
            projectFindView.replaceEditor.setText('sunshine');
            return projectFindView.replaceAllButton.click();
          });
          waitsForPromise(function() {
            return replacePromise;
          });
          return runs(function() {
            var sampleCoffeeContent, sampleJsContent;
            expect(projectFindView.errorMessages).not.toBeVisible();
            expect(projectFindView.descriptionLabel.text()).toContain('Replaced');
            sampleJsContent = fs.readFileSync(sampleJs, 'utf8');
            expect(sampleJsContent.match(/items/g)).toBeFalsy();
            expect(sampleJsContent.match(/sunshine/g)).toHaveLength(6);
            sampleCoffeeContent = fs.readFileSync(sampleCoffee, 'utf8');
            expect(sampleCoffeeContent.match(/items/g)).toBeFalsy();
            return expect(sampleCoffeeContent.match(/sunshine/g)).toHaveLength(7);
          });
        });
        return describe("when there are search results after a replace", function() {
          return it("runs the search after the replace", function() {
            projectFindView.findEditor.setText('items');
            projectFindView.trigger('core:confirm');
            waitsForPromise(function() {
              return searchPromise;
            });
            runs(function() {
              projectFindView.replaceEditor.setText('items-123');
              return projectFindView.replaceAllButton.click();
            });
            waitsForPromise(function() {
              return replacePromise;
            });
            return runs(function() {
              expect(projectFindView.errorMessages).not.toBeVisible();
              expect(getExistingResultsPane().previewCount.text()).toContain('13 results found in 2 files for items');
              expect(projectFindView.descriptionLabel.text()).toContain('Replaced items with items-123 13 times in 2 files');
              projectFindView.replaceEditor.setText('cats');
              advanceClock(projectFindView.replaceEditor.getEditor().getBuffer().stoppedChangingDelay);
              expect(projectFindView.descriptionLabel.text()).not.toContain('Replaced items');
              return expect(projectFindView.descriptionLabel.text()).toContain("13 results found in 2 files for items");
            });
          });
        });
      });
      return describe("when the project-find:replace-all is triggered", function() {
        describe("when there are no results", function() {
          return it("doesnt replace anything", function() {
            projectFindView.findEditor.setText('nopenotinthefile');
            projectFindView.replaceEditor.setText('sunshine');
            spyOn(atom.project, 'scan').andCallThrough();
            spyOn(atom, 'beep');
            projectFindView.trigger('project-find:replace-all');
            waitsForPromise(function() {
              return replacePromise;
            });
            return runs(function() {
              expect(atom.project.scan).toHaveBeenCalled();
              expect(atom.beep).toHaveBeenCalled();
              return expect(projectFindView.descriptionLabel.text()).toContain("Nothing replaced");
            });
          });
        });
        describe("when no search has been run", function() {
          return it("runs the search then replaces everything", function() {
            projectFindView.findEditor.setText('items');
            projectFindView.replaceEditor.setText('sunshine');
            projectFindView.trigger('project-find:replace-all');
            waitsForPromise(function() {
              return replacePromise;
            });
            return runs(function() {
              return expect(projectFindView.descriptionLabel.text()).toContain("Replaced items with sunshine 13 times in 2 files");
            });
          });
        });
        describe("when the search text has changed since that last search", function() {
          beforeEach(function() {
            projectFindView.findEditor.setText('items');
            projectFindView.trigger('core:confirm');
            return waitsForPromise(function() {
              return searchPromise;
            });
          });
          return it("clears the search results and does another replace", function() {
            spyOn(atom.project, 'scan').andCallThrough();
            spyOn(atom, 'beep');
            projectFindView.findEditor.setText('sort');
            projectFindView.replaceEditor.setText('ok');
            expect(projectFindView.resultsView).not.toBeVisible();
            projectFindView.trigger('project-find:replace-all');
            waitsForPromise(function() {
              return replacePromise;
            });
            return runs(function() {
              expect(atom.project.scan).toHaveBeenCalled();
              expect(atom.beep).not.toHaveBeenCalled();
              return expect(projectFindView.descriptionLabel.text()).toContain("Replaced sort with ok 10 times in 2 files");
            });
          });
        });
        return describe("when the text in the search box triggered the results", function() {
          beforeEach(function() {
            projectFindView.findEditor.setText('items');
            projectFindView.trigger('core:confirm');
            return waitsForPromise(function() {
              return searchPromise;
            });
          });
          return it("runs the search, and replaces all the matches", function() {
            projectFindView.replaceEditor.setText('sunshine');
            projectFindView.trigger('project-find:replace-all');
            expect(projectFindView.errorMessages).not.toBeVisible();
            waitsForPromise(function() {
              return replacePromise;
            });
            return runs(function() {
              var resultsPaneView, resultsView, sampleCoffeeContent, sampleJsContent;
              resultsPaneView = getExistingResultsPane();
              resultsView = resultsPaneView.resultsView;
              expect(resultsView).toBeVisible();
              expect(resultsView.find("li > ul > li")).toHaveLength(0);
              expect(projectFindView.descriptionLabel.text()).toContain("Replaced items with sunshine 13 times in 2 files");
              sampleJsContent = fs.readFileSync(sampleJs, 'utf8');
              expect(sampleJsContent.match(/items/g)).toBeFalsy();
              expect(sampleJsContent.match(/sunshine/g)).toHaveLength(6);
              sampleCoffeeContent = fs.readFileSync(sampleCoffee, 'utf8');
              expect(sampleCoffeeContent.match(/items/g)).toBeFalsy();
              return expect(sampleCoffeeContent.match(/sunshine/g)).toHaveLength(7);
            });
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/find-and-replace/spec/project-find-view-spec.js.map
