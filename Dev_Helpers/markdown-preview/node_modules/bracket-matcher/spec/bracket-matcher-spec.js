(function() {
  var WorkspaceView, path;

  WorkspaceView = require('atom').WorkspaceView;

  path = require('path');

  describe("bracket matching", function() {
    var buffer, editor, editorView, _ref;
    _ref = [], editorView = _ref[0], editor = _ref[1], buffer = _ref[2];
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.attachToDom();
      atom.workspaceView.openSync('sample.js');
      waitsForPromise(function() {
        return atom.packages.activatePackage('bracket-matcher');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
      return runs(function() {
        editorView = atom.workspaceView.getActiveView();
        editor = editorView.editor;
        return buffer = editor.buffer, editor;
      });
    });
    describe("matching bracket highlighting", function() {
      describe("when the cursor is before a starting pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          expect(editorView.underlayer.find('.bracket-matcher:first').width()).toBeGreaterThan(0);
          expect(editorView.underlayer.find('.bracket-matcher:last').width()).toBeGreaterThan(0);
          expect(editorView.underlayer.find('.bracket-matcher:first').height()).toBeGreaterThan(0);
          return expect(editorView.underlayer.find('.bracket-matcher:last').height()).toBeGreaterThan(0);
        });
      });
      describe("when the cursor is after a starting pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToEndOfLine();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
        });
      });
      describe("when the cursor is before an ending pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("when the cursor is after an ending pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("when the cursor is moved off a pair", function() {
        return it("removes the starting pair and ending pair highlights", function() {
          editor.moveCursorToEndOfLine();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          editor.moveCursorToBeginningOfLine();
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(0);
        });
      });
      describe("when the pair moves", function() {
        return it("repositions the highlights", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          editor.backspaceToBeginningOfLine();
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
        });
      });
      describe("when the font size changes", function() {
        return it("repositions the highlights", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          atom.config.set('editor.fontSize', editorView.getFontSize() + 10);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      return describe("pair balancing", function() {
        return describe("when a second starting pair preceeds the first ending pair", function() {
          return it("advances to the second ending pair", function() {
            editor.setCursorBufferPosition([8, 42]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([8, 42]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([8, 54]));
          });
        });
      });
    });
    describe("when bracket-matcher:go-to-matching-bracket is triggered", function() {
      describe("when the cursor is before the starting pair", function() {
        return it("moves the cursor to after the ending pair", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([12, 1]);
        });
      });
      describe("when the cursor is after the starting pair", function() {
        return it("moves the cursor to before the ending pair", function() {
          editor.moveCursorToEndOfLine();
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([12, 0]);
        });
      });
      describe("when the cursor is before the ending pair", function() {
        return it("moves the cursor to after the starting pair", function() {
          editor.setCursorBufferPosition([12, 0]);
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 29]);
        });
      });
      describe("when the cursor is after the ending pair", function() {
        return it("moves the cursor to before the starting pair", function() {
          editor.setCursorBufferPosition([12, 1]);
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
        });
      });
      return describe("when the cursor is not adjacent to a pair", function() {
        describe("when within a `{}` pair", function() {
          return it("moves the cursor to before the enclosing brace", function() {
            editor.setCursorBufferPosition([11, 2]);
            editorView.trigger("bracket-matcher:go-to-matching-bracket");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
          });
        });
        return describe("when within a `()` pair", function() {
          return it("moves the cursor to before the enclosing brace", function() {
            editor.setCursorBufferPosition([2, 14]);
            editorView.trigger("bracket-matcher:go-to-matching-bracket");
            return expect(editor.getCursorBufferPosition()).toEqual([2, 7]);
          });
        });
      });
    });
    describe("when bracket-matcher:go-to-enclosing-bracket is triggered", function() {
      describe("when within a `{}` pair", function() {
        return it("moves the cursor to before the enclosing brace", function() {
          editor.setCursorBufferPosition([11, 2]);
          editorView.trigger("bracket-matcher:go-to-enclosing-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
        });
      });
      return describe("when within a `()` pair", function() {
        return it("moves the cursor to before the enclosing brace", function() {
          editor.setCursorBufferPosition([2, 14]);
          editorView.trigger("bracket-matcher:go-to-enclosing-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([2, 7]);
        });
      });
    });
    describe("matching bracket insertion", function() {
      beforeEach(function() {
        return editor.buffer.setText("");
      });
      describe("when more than one character is inserted", function() {
        return it("does not insert a matching bracket", function() {
          editor.insertText("woah(");
          return expect(editor.buffer.getText()).toBe("woah(");
        });
      });
      describe("when there is a word character after the cursor", function() {
        return it("does not insert a matching bracket", function() {
          editor.buffer.setText("ab");
          editor.setCursorBufferPosition([0, 1]);
          editor.insertText("(");
          return expect(editor.buffer.getText()).toBe("a(b");
        });
      });
      describe("when there are multiple cursors", function() {
        return it("inserts ) at each cursor", function() {
          editor.buffer.setText("()\nab\n[]\n12");
          editor.setCursorBufferPosition([3, 1]);
          editor.addCursorAtBufferPosition([2, 1]);
          editor.addCursorAtBufferPosition([1, 1]);
          editor.addCursorAtBufferPosition([0, 1]);
          editor.insertText(')');
          return expect(editor.buffer.getText()).toBe("())\na)b\n[)]\n1)2");
        });
      });
      describe("when there is a non-word character after the cursor", function() {
        return it("inserts a closing bracket after an opening bracket is inserted", function() {
          editor.buffer.setText("}");
          editor.setCursorBufferPosition([0, 0]);
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe("{}}");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        });
      });
      describe("when the cursor is at the end of the line", function() {
        return it("inserts a closing bracket after an opening bracket is inserted", function() {
          editor.buffer.setText("");
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe("{}");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('(');
          expect(buffer.lineForRow(0)).toBe("()");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('[');
          expect(buffer.lineForRow(0)).toBe("[]");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('"');
          expect(buffer.lineForRow(0)).toBe('""');
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText("'");
          expect(buffer.lineForRow(0)).toBe("''");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        });
      });
      describe("when the cursor is on a closing bracket and a closing bracket is inserted", function() {
        describe("when the closing bracket was there previously", function() {
          return it("inserts a closing bracket", function() {
            editor.insertText('()x');
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("())x");
            return expect(editor.getCursorBufferPosition().column).toBe(2);
          });
        });
        return describe("when the closing bracket was automatically inserted from inserting an opening bracket", function() {
          it("only moves cursor over the closing bracket one time", function() {
            editor.insertText('(');
            expect(buffer.lineForRow(0)).toBe("()");
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("()");
            expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("())");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
          });
          it("moves cursor over the closing bracket after other text is inserted", function() {
            editor.insertText('(');
            editor.insertText('ok cool');
            expect(buffer.lineForRow(0)).toBe("(ok cool)");
            editor.setCursorBufferPosition([0, 8]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(ok cool)");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 9]);
          });
          it("works with nested brackets", function() {
            editor.insertText('(');
            editor.insertText('1');
            editor.insertText('(');
            editor.insertText('2');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            editor.setCursorBufferPosition([0, 4]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            expect(editor.getCursorBufferPosition()).toEqual([0, 5]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
          });
          it("works with mixed brackets", function() {
            editor.insertText('(');
            editor.insertText('}');
            expect(buffer.lineForRow(0)).toBe("(})");
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(})");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
          });
          return it("closes brackets with the same begin/end character correctly", function() {
            editor.insertText('"');
            editor.insertText('ok');
            expect(buffer.lineForRow(0)).toBe('"ok"');
            expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe('"ok"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
          });
        });
      });
      describe("when there is text selected on a single line", function() {
        return it("wraps the selection with brackets", function() {
          editor.insertText('text');
          editor.moveCursorToBottom();
          editor.selectToTop();
          editor.selectAll();
          editor.insertText('(');
          expect('(text)').toBe(buffer.getText());
          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 5]]);
          return expect(editor.getSelection().isReversed()).toBeTruthy();
        });
      });
      describe("when there is text selected on multiple lines", function() {
        return it("wraps the selection with brackets", function() {
          editor.insertText('text\nabcd');
          editor.moveCursorToBottom();
          editor.selectToTop();
          editor.selectAll();
          editor.insertText('(');
          expect('(text\nabcd)').toBe(buffer.getText());
          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [1, 4]]);
          return expect(editor.getSelection().isReversed()).toBeTruthy();
        });
      });
      describe("when inserting a quote", function() {
        describe("when a word character is before the cursor", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("abc");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("abc\"");
            editor.buffer.setText("abc");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('\'');
            return expect(buffer.lineForRow(0)).toBe("abc\'");
          });
        });
        describe("when a quote is before the cursor", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("''");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText("'");
            expect(buffer.lineForRow(0)).toBe("'''");
            editor.buffer.setText('""');
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe('"""');
            editor.buffer.setText("''");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            return expect(buffer.lineForRow(0)).toBe("''\"\"");
          });
        });
        describe("when a non word character is before the cursor", function() {
          return it("automatically inserts the closing quote", function() {
            editor.buffer.setText("ab@");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("ab@\"\"");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
          });
        });
        describe("when the cursor is on an empty line", function() {
          return it("automatically inserts the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("\"\"");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
        describe("when the select option to Editor::insertText is true", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"', {
              select: true
            });
            expect(buffer.lineForRow(0)).toBe('"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
        return describe("when the undo option to Editor::insertText is 'skip'", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"', {
              undo: 'skip'
            });
            expect(buffer.lineForRow(0)).toBe('"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
      });
      return describe("when return is pressed inside a matching pair", function() {
        it("puts cursor on autoindented empty line", function() {
          editor.insertText('void main() ');
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe('void main() {}');
          editor.insertNewline();
          expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
          expect(buffer.lineForRow(1)).toBe('  ');
          expect(buffer.lineForRow(2)).toBe('}');
          editor.setText('  void main() ');
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe('  void main() {}');
          editor.insertNewline();
          expect(editor.getCursorBufferPosition()).toEqual([1, 4]);
          expect(buffer.lineForRow(1)).toBe('    ');
          return expect(buffer.lineForRow(2)).toBe('  }');
        });
        return describe("when undo is triggered", function() {
          return it("removes both newlines", function() {
            editor.insertText('void main() ');
            editor.insertText('{');
            editor.insertNewline();
            editor.undo();
            return expect(buffer.lineForRow(0)).toBe('void main() {}');
          });
        });
      });
    });
    return describe("matching bracket deletion", function() {
      return it("deletes the end bracket when it directly proceeds a begin bracket that is being backspaced", function() {
        buffer.setText("");
        editor.setCursorBufferPosition([0, 0]);
        editor.insertText('{');
        expect(buffer.lineForRow(0)).toBe("{}");
        editor.backspace();
        return expect(buffer.lineForRow(0)).toBe("");
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/bracket-matcher/spec/bracket-matcher-spec.js.map
