(function() {
  var Snippet, Snippets, WorkspaceView, fs, path, temp;

  path = require('path');

  WorkspaceView = require('atom').WorkspaceView;

  fs = require('fs-plus');

  temp = require('temp');

  Snippet = require('../lib/snippet');

  Snippets = require('../lib/snippets');

  describe("Snippets extension", function() {
    var buffer, editor, editorView, snippets, _ref;
    _ref = [], buffer = _ref[0], editorView = _ref[1], editor = _ref[2], snippets = _ref[3];
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.openSync('sample.js');
      spyOn(Snippets, 'loadAll');
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage("snippets").then(function(_arg) {
          var mainModule;
          mainModule = _arg.mainModule;
          return snippets = mainModule;
        });
      });
      return runs(function() {
        editorView = atom.workspaceView.getActiveView();
        editor = atom.workspaceView.getActivePaneItem();
        buffer = editor.getBuffer();
        atom.workspaceView.simulateDomAttachment();
        return atom.workspaceView.enableKeymap();
      });
    });
    describe("when 'tab' is triggered on the editorView", function() {
      beforeEach(function() {
        return snippets.add(__filename, {
          ".source.js": {
            "without tab stops": {
              prefix: "t1",
              body: "this is a test"
            },
            "overlapping prefix": {
              prefix: "tt1",
              body: "this is another test"
            },
            "special chars": {
              prefix: "@unique",
              body: "@unique see"
            },
            "tab stops": {
              prefix: "t2",
              body: "go here next:($2) and finally go here:($0)\ngo here first:($1)\n"
            },
            "indented second line": {
              prefix: "t3",
              body: "line 1\n\tline 2$1\n"
            },
            "nested tab stops": {
              prefix: "t5",
              body: '${1:"${2:key}"}: ${3:value}'
            },
            "caused problems with undo": {
              prefix: "t6",
              body: "first line$1\n  ${2:placeholder ending second line}"
            },
            "contains empty lines": {
              prefix: "t7",
              body: "first line $1\n\n\nfourth line after blanks $2"
            },
            "with/without placeholder": {
              prefix: "t8",
              body: "with placeholder ${1:test}\nwithout placeholder ${2}"
            }
          }
        });
      });
      describe("when the letters preceding the cursor trigger a snippet", function() {
        describe("when the snippet contains no tab stops", function() {
          it("replaces the prefix with the snippet text and places the cursor at its end", function() {
            editor.insertText("t1");
            expect(editor.getCursorScreenPosition()).toEqual([0, 2]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(0)).toBe("this is a testvar quicksort = function () {");
            return expect(editor.getCursorScreenPosition()).toEqual([0, 14]);
          });
          return it("inserts a real tab the next time a tab is pressed after the snippet is expanded", function() {
            editor.insertText("t1");
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(0)).toBe("this is a testvar quicksort = function () {");
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            return expect(buffer.lineForRow(0)).toBe("this is a test  var quicksort = function () {");
          });
        });
        describe("when the snippet contains tab stops", function() {
          it("places the cursor at the first tab-stop, and moves the cursor in response to 'next-tab-stop' events", function() {
            var markerCountBefore;
            markerCountBefore = editor.getMarkerCount();
            editor.setCursorScreenPosition([2, 0]);
            editor.insertText('t2');
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(2)).toBe("go here next:() and finally go here:()");
            expect(buffer.lineForRow(3)).toBe("go here first:()");
            expect(buffer.lineForRow(4)).toBe("    if (items.length <= 1) return items;");
            expect(editor.getSelectedBufferRange()).toEqual([[3, 15], [3, 15]]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(editor.getSelectedBufferRange()).toEqual([[2, 14], [2, 14]]);
            editor.insertText('abc');
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(editor.getSelectedBufferRange()).toEqual([[2, 40], [2, 40]]);
            editorView.trigger(keydownEvent('tab', {
              shiftKey: true,
              target: editorView[0]
            }));
            expect(editor.getSelectedBufferRange()).toEqual([[2, 14], [2, 17]]);
            editorView.trigger(keydownEvent('tab', {
              shiftKey: true,
              target: editorView[0]
            }));
            expect(editor.getSelectedBufferRange()).toEqual([[3, 15], [3, 15]]);
            editorView.trigger(keydownEvent('tab', {
              shiftKey: true,
              target: editorView[0]
            }));
            expect(editor.getCursorScreenPosition()).toEqual([3, 15]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(2)).toBe("go here next:(abc) and finally go here:(  )");
            return expect(editor.getMarkerCount()).toBe(markerCountBefore);
          });
          describe("when tab stops are nested", function() {
            return it("destroys the inner tab stop if the outer tab stop is modified", function() {
              buffer.setText('');
              editor.insertText('t5');
              editorView.trigger('snippets:expand');
              expect(buffer.lineForRow(0)).toBe('"key": value');
              expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 5]]);
              editor.insertText("foo");
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              return expect(editor.getSelectedBufferRange()).toEqual([[0, 5], [0, 10]]);
            });
          });
          describe("when tab stops are separated by blank lines", function() {
            return it("correctly places the tab stops (regression)", function() {
              buffer.setText('');
              editor.insertText('t7');
              editorView.trigger('snippets:expand');
              editorView.trigger('snippets:next-tab-stop');
              return expect(editor.getCursorBufferPosition()).toEqual([3, 25]);
            });
          });
          return describe("when the cursor is moved beyond the bounds of the current tab stop", function() {
            return it("terminates the snippet", function() {
              editor.setCursorScreenPosition([2, 0]);
              editor.insertText('t2');
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              editor.moveCursorUp();
              editor.moveCursorLeft();
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              expect(buffer.lineForRow(2)).toBe("go here next:(  ) and finally go here:()");
              expect(editor.getCursorBufferPosition()).toEqual([2, 16]);
              editor.setCursorScreenPosition([4, 0]);
              editor.insertText('t2');
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              editor.moveCursorRight();
              editorView.trigger(keydownEvent('tab', {
                shiftKey: true,
                target: editorView[0]
              }));
              return expect(editor.getCursorBufferPosition()).toEqual([4, 15]);
            });
          });
        });
        describe("when the snippet contains hard tabs", function() {
          describe("when the edit session is in soft-tabs mode", function() {
            return it("translates hard tabs in the snippet to the appropriate number of spaces", function() {
              expect(editor.getSoftTabs()).toBeTruthy();
              editor.insertText("t3");
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              expect(buffer.lineForRow(1)).toBe("  line 2");
              return expect(editor.getCursorBufferPosition()).toEqual([1, 8]);
            });
          });
          return describe("when the edit session is in hard-tabs mode", function() {
            return it("inserts hard tabs in the snippet directly", function() {
              editor.setSoftTabs(false);
              editor.insertText("t3");
              editorView.trigger(keydownEvent('tab', {
                target: editorView[0]
              }));
              expect(buffer.lineForRow(1)).toBe("\tline 2");
              return expect(editor.getCursorBufferPosition()).toEqual([1, 7]);
            });
          });
        });
        describe("when the snippet prefix is indented", function() {
          describe("when the snippet spans a single line", function() {
            return it("does not indent the next line", function() {
              editor.setCursorScreenPosition([2, Infinity]);
              editor.insertText(' t1');
              editorView.trigger('snippets:expand');
              return expect(buffer.lineForRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
            });
          });
          return describe("when the snippet spans multiple lines", function() {
            return it("indents the subsequent lines of the snippet to be even with the start of the first line", function() {
              expect(editor.getSoftTabs()).toBeTruthy();
              editor.setCursorScreenPosition([2, Infinity]);
              editor.insertText(' t3');
              editorView.trigger('snippets:expand');
              expect(buffer.lineForRow(2)).toBe("    if (items.length <= 1) return items; line 1");
              expect(buffer.lineForRow(3)).toBe("      line 2");
              return expect(editor.getCursorBufferPosition()).toEqual([3, 12]);
            });
          });
        });
        return describe("when multiple snippets match the prefix", function() {
          return it("expands the snippet that is the longest match for the prefix", function() {
            editor.insertText('t13');
            expect(editor.getCursorScreenPosition()).toEqual([0, 3]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(0)).toBe("t13  var quicksort = function () {");
            expect(editor.getCursorScreenPosition()).toEqual([0, 5]);
            editor.undo();
            editor.undo();
            editor.insertText("tt1");
            expect(editor.getCursorScreenPosition()).toEqual([0, 3]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(0)).toBe("this is another testvar quicksort = function () {");
            expect(editor.getCursorScreenPosition()).toEqual([0, 20]);
            editor.undo();
            editor.undo();
            editor.insertText("@t1");
            expect(editor.getCursorScreenPosition()).toEqual([0, 3]);
            editorView.trigger(keydownEvent('tab', {
              target: editorView[0]
            }));
            expect(buffer.lineForRow(0)).toBe("@this is a testvar quicksort = function () {");
            return expect(editor.getCursorScreenPosition()).toEqual([0, 15]);
          });
        });
      });
      describe("when the letters preceding the cursor don't match a snippet", function() {
        return it("inserts a tab as normal", function() {
          editor.insertText("xte");
          expect(editor.getCursorScreenPosition()).toEqual([0, 3]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("xte  var quicksort = function () {");
          return expect(editor.getCursorScreenPosition()).toEqual([0, 5]);
        });
      });
      describe("when text is selected", function() {
        return it("inserts a tab as normal", function() {
          editor.insertText("t1");
          editor.setSelectedBufferRange([[0, 0], [0, 2]]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("  t1var quicksort = function () {");
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 4]]);
        });
      });
      describe("when a previous snippet expansion has just been undone", function() {
        return it("expands the snippet based on the current prefix rather than jumping to the old snippet's tab stop", function() {
          editor.insertText('t6\n');
          editor.setCursorBufferPosition([0, 2]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("first line");
          editor.undo();
          expect(buffer.lineForRow(0)).toBe("t6");
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          return expect(buffer.lineForRow(0)).toBe("first line");
        });
      });
      describe("when the prefix contains non-word characters", function() {
        it("selects the non-word characters as part of the prefix", function() {
          editor.insertText("@unique");
          expect(editor.getCursorScreenPosition()).toEqual([0, 7]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("@unique seevar quicksort = function () {");
          expect(editor.getCursorScreenPosition()).toEqual([0, 11]);
          editor.setCursorBufferPosition([10, 0]);
          editor.insertText("'@unique");
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(10)).toBe("'@unique see");
          return expect(editor.getCursorScreenPosition()).toEqual([10, 12]);
        });
        return it("does not select the whitespace before the prefix", function() {
          editor.insertText("a; @unique");
          expect(editor.getCursorScreenPosition()).toEqual([0, 10]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("a; @unique seevar quicksort = function () {");
          return expect(editor.getCursorScreenPosition()).toEqual([0, 14]);
        });
      });
      return describe("when snippet contains tabstops with or without placeholder", function() {
        return it("should create two markers", function() {
          var markerCountBefore;
          markerCountBefore = editor.getMarkerCount();
          editor.setCursorScreenPosition([0, 0]);
          editor.insertText('t8');
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          expect(buffer.lineForRow(0)).toBe("with placeholder test");
          expect(buffer.lineForRow(1)).toBe("without placeholder var quicksort = function () {");
          expect(editor.getMarkerCount()).toBe(3);
          expect(editor.getSelectedBufferRange()).toEqual([[0, 17], [0, 21]]);
          editorView.trigger(keydownEvent('tab', {
            target: editorView[0]
          }));
          return expect(editor.getSelectedBufferRange()).toEqual([[1, 20], [1, 20]]);
        });
      });
    });
    describe("snippet loading", function() {
      var configDirPath, packageWithBrokenSnippets, packageWithSnippets, _ref1;
      _ref1 = [], configDirPath = _ref1[0], packageWithSnippets = _ref1[1], packageWithBrokenSnippets = _ref1[2];
      beforeEach(function() {
        packageWithBrokenSnippets = atom.packages.loadPackage(path.join(__dirname, 'fixtures', 'package-with-broken-snippets'));
        packageWithSnippets = atom.packages.loadPackage(path.join(__dirname, 'fixtures', 'package-with-snippets'));
        configDirPath = temp.mkdirSync('atom-config-dir-');
        jasmine.unspy(window, "setTimeout");
        jasmine.unspy(snippets, 'loadAll');
        spyOn(atom.packages, 'getLoadedPackages').andReturn([packageWithSnippets, packageWithBrokenSnippets]);
        return spyOn(atom, 'getConfigDirPath').andReturn(configDirPath);
      });
      afterEach(function() {
        return jasmine.unspy(atom.packages, 'getLoadedPackages');
      });
      it("loads non-hidden snippet files from all atom packages with snippets directories, logging a warning if a file can't be parsed", function() {
        spyOn(console, 'warn');
        snippets.loaded = false;
        snippets.loadAll();
        waitsFor("all snippets to load", 30000, function() {
          return snippets.loaded;
        });
        return runs(function() {
          var _ref2;
          expect((_ref2 = atom.syntax.getProperty(['.test'], 'snippets.test')) != null ? _ref2.constructor : void 0).toBe(Snippet);
          expect(console.warn).toHaveBeenCalled();
          return expect(console.warn.calls.length).toBe(1);
        });
      });
      it("loads ~/.atom/snippets.json when it exists", function() {
        fs.writeFileSync(path.join(configDirPath, 'snippets.json'), "{\n  \".foo\": {\n    \"foo snippet\": {\n      \"prefix\": \"foo\",\n      \"body\": \"bar\"\n    }\n  }\n}");
        spyOn(console, 'warn');
        snippets.loaded = false;
        snippets.loadAll();
        waitsFor("all snippets to load", 30000, function() {
          return snippets.loaded;
        });
        return runs(function() {
          var _ref2;
          return expect((_ref2 = atom.syntax.getProperty(['.foo'], 'snippets.foo')) != null ? _ref2.constructor : void 0).toBe(Snippet);
        });
      });
      it("loads ~/.atom/snippets.cson when it exists", function() {
        fs.writeFileSync(path.join(configDirPath, 'snippets.cson'), "\".foo\":\n  \"foo snippet\":\n    \"prefix\": \"foo\"\n    \"body\": \"bar\"");
        spyOn(console, 'warn');
        snippets.loaded = false;
        snippets.loadAll();
        waitsFor("all snippets to load", 30000, function() {
          return snippets.loaded;
        });
        return runs(function() {
          var _ref2;
          return expect((_ref2 = atom.syntax.getProperty(['.foo'], 'snippets.foo')) != null ? _ref2.constructor : void 0).toBe(Snippet);
        });
      });
      return it("loads the bundled snippet template snippets", function() {
        spyOn(console, 'warn');
        snippets.loaded = false;
        snippets.loadAll();
        waitsFor("all snippets to load", 30000, function() {
          return snippets.loaded;
        });
        return runs(function() {
          var _ref2, _ref3;
          expect((_ref2 = atom.syntax.getProperty(['.source.json'], 'snippets.snip')) != null ? _ref2.constructor : void 0).toBe(Snippet);
          return expect((_ref3 = atom.syntax.getProperty(['.source.coffee'], 'snippets.snip')) != null ? _ref3.constructor : void 0).toBe(Snippet);
        });
      });
    });
    describe("snippet body parser", function() {
      it("breaks a snippet body into lines, with each line containing tab stops at the appropriate position", function() {
        var bodyTree;
        bodyTree = snippets.getBodyParser().parse("the quick brown $1fox ${2:jumped ${3:over}\n}the ${4:lazy} dog");
        return expect(bodyTree).toEqual([
          "the quick brown ", {
            index: 1,
            content: []
          }, "fox ", {
            index: 2,
            content: [
              "jumped ", {
                index: 3,
                content: ["over"]
              }, "\n"
            ]
          }, "the ", {
            index: 4,
            content: ["lazy"]
          }, " dog"
        ]);
      });
      return it("removes interpolated variables in placeholder text (we don't currently support it)", function() {
        var bodyTree;
        bodyTree = snippets.getBodyParser().parse("module ${1:ActiveRecord::${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}");
        return expect(bodyTree).toEqual([
          "module ", {
            "index": 1,
            "content": ["ActiveRecord::", ""]
          }
        ]);
      });
    });
    describe("when atom://.atom/snippets is opened", function() {
      return it("opens ~/.atom/snippets.cson", function() {
        var configDirPath;
        atom.workspaceView.destroyActivePaneItem();
        configDirPath = temp.mkdirSync('atom-config-dir-');
        spyOn(atom, 'getConfigDirPath').andReturn(configDirPath);
        atom.workspaceView.open('atom://.atom/snippets');
        waitsFor(function() {
          return atom.workspaceView.getActivePaneItem() != null;
        });
        return runs(function() {
          return expect(atom.workspaceView.getActivePaneItem().getUri()).toBe(path.join(configDirPath, 'snippets.cson'));
        });
      });
    });
    describe("when ~/.atom/snippets.cson changes", function() {
      return it("reloads the snippets", function() {
        var configDirPath, snippetsPath;
        jasmine.unspy(window, "setTimeout");
        jasmine.unspy(snippets, 'loadAll');
        spyOn(snippets, 'loadPackageSnippets').andCallFake(function() {
          return process.nextTick(function() {
            return snippets.doneLoading();
          });
        });
        configDirPath = temp.mkdirSync('atom-config-dir-');
        spyOn(atom, 'getConfigDirPath').andReturn(configDirPath);
        snippetsPath = path.join(configDirPath, 'snippets.cson');
        fs.writeFileSync(snippetsPath, '');
        snippets.loaded = false;
        snippets.loadAll();
        waitsFor("all snippets to load", 30000, function() {
          return snippets.loaded;
        });
        runs(function() {
          expect(atom.syntax.getProperty(['.test'], 'snippets.test')).toBeUndefined();
          return fs.writeFileSync(snippetsPath, "\".test\":\n  \"Test Snippet\":\n    prefix: \"test\"\n    body: \"testing 123\"");
        });
        waitsFor("snippets to be added", function() {
          return atom.syntax.getProperty(['.test'], 'snippets.test') != null;
        });
        runs(function() {
          var _ref1;
          expect((_ref1 = atom.syntax.getProperty(['.test'], 'snippets.test')) != null ? _ref1.constructor : void 0).toBe(Snippet);
          return fs.removeSync(snippetsPath);
        });
        return waitsFor("snippets to be removed", function() {
          return atom.syntax.getProperty(['.test'], 'snippets.test') != null;
        });
      });
    });
    return describe("snippet insertion API", function() {
      return it("will automatically parse snippet definition and replace selection", function() {
        editor.setSelectedBufferRange([[0, 4], [0, 13]]);
        Snippets.insert("hello ${1:world}", editor);
        expect(buffer.lineForRow(0)).toBe("var hello world = function () {");
        expect(editor.getMarkerCount()).toBe(2);
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 10], [0, 15]]);
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/snippets/spec/snippets-spec.js.map
