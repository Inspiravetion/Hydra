{
  "name": "loophole",
  "version": "0.1.0",
  "description": "A hack to enable use of libraries that depend on a basic form of eval in Atom",
  "main": "./lib/loophole.js",
  "scripts": {
    "prepublish": "grunt clean lint coffee",
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/atom/loophole.git"
  },
  "bugs": {
    "url": "https://github.com/atom/loophole/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/atom/loophole/raw/master/LICENSE.md"
    }
  ],
  "devDependencies": {
    "coffee-script": "~1.7.0",
    "jasmine-focused": "1.x",
    "grunt-contrib-coffee": "~0.9.0",
    "grunt-cli": "~0.1.8",
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "grunt-coffeelint": "0.0.6",
    "rimraf": "~2.2.2",
    "temp": "~0.6.0"
  },
  "readme": "# Eval Loophole\n\nThis is a hack to enable third-party libraries that depend on a limited subset\nof `eval` semantics to work in Atom with a content security policy that forbids\ncalls to `eval`.\n\n```coffee\n{allowUnsafeEval} = require 'loophole'\n\nallowUnsafeEval ->\n  crazyLibrary.exploitLoophole()\n```\n\n## How?\n\nIt replaces `eval` with a call two `vm.runInThisContext`, which won't perfectly\nemulate `eval` but is good enough in certain circumstances, like compiling\n[PEG.js][peg-js] grammars.\n\n## Why?\n\nIf there's a loophole, why even enable CSP? It still prevents developers from\naccidentally invoking eval with legacy libraries. For example, did you know that\njQuery runs eval when you pass it content with script tags? If you want eval,\nyou'll need to explicitly ask for it.\n\n[peg-js]: http://pegjs.majda.cz/\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/atom/loophole",
  "_id": "loophole@0.1.0",
  "dist": {
    "shasum": "34603860d1d13102df39939d4c24b16c76ef1cda"
  },
  "_from": "loophole@^0.1.0",
  "_resolved": "https://registry.npmjs.org/loophole/-/loophole-0.1.0.tgz"
}
