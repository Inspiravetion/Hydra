(function() {
  var CSON, File, Snippet, SnippetExpansion, async, fs, path, _;

  path = require('path');

  _ = require('underscore-plus');

  async = require('async');

  CSON = require('season');

  File = require('pathwatcher').File;

  fs = require('fs-plus');

  Snippet = require('./snippet');

  SnippetExpansion = require('./snippet-expansion');

  module.exports = {
    loaded: false,
    activate: function() {
      atom.project.registerOpener((function(_this) {
        return function(uri) {
          if (uri === 'atom://.atom/snippets') {
            return atom.workspaceView.open(_this.getUserSnippetsPath());
          }
        };
      })(this));
      this.loadAll();
      return atom.workspaceView.eachEditorView((function(_this) {
        return function(editorView) {
          if (editorView.attached) {
            return _this.enableSnippetsInEditor(editorView);
          }
        };
      })(this));
    },
    deactivate: function() {
      var _ref;
      return (_ref = this.userSnippetsFile) != null ? _ref.off() : void 0;
    },
    getUserSnippetsPath: function() {
      var userSnippetsPath;
      userSnippetsPath = CSON.resolve(path.join(atom.getConfigDirPath(), 'snippets'));
      return userSnippetsPath != null ? userSnippetsPath : path.join(atom.getConfigDirPath(), 'snippets.cson');
    },
    loadAll: function() {
      return this.loadBundledSnippets((function(_this) {
        return function() {
          return _this.loadUserSnippets(function() {
            return _this.loadPackageSnippets();
          });
        };
      })(this));
    },
    loadBundledSnippets: function(callback) {
      var bundledSnippetsPath;
      bundledSnippetsPath = CSON.resolve(path.join(__dirname, 'snippets'));
      return this.loadSnippetsFile(bundledSnippetsPath, callback);
    },
    loadUserSnippets: function(callback) {
      var userSnippetsPath, _ref;
      if ((_ref = this.userSnippetsFile) != null) {
        _ref.off();
      }
      userSnippetsPath = this.getUserSnippetsPath();
      return fs.stat(userSnippetsPath, (function(_this) {
        return function(error, stat) {
          if (stat != null ? stat.isFile() : void 0) {
            _this.userSnippetsFile = new File(userSnippetsPath);
            _this.userSnippetsFile.on('moved removed contents-changed', function() {
              atom.syntax.removeProperties(userSnippetsPath);
              return _this.loadUserSnippets();
            });
            return _this.loadSnippetsFile(userSnippetsPath, callback);
          } else {
            return typeof callback === "function" ? callback() : void 0;
          }
        };
      })(this));
    },
    loadPackageSnippets: function() {
      var pack, packages, snippetsDirPaths, _i, _len;
      packages = atom.packages.getLoadedPackages();
      snippetsDirPaths = [];
      for (_i = 0, _len = packages.length; _i < _len; _i++) {
        pack = packages[_i];
        snippetsDirPaths.push(path.join(pack.path, 'snippets'));
      }
      return async.eachSeries(snippetsDirPaths, this.loadSnippetsDirectory.bind(this), this.doneLoading.bind(this));
    },
    doneLoading: function() {
      atom.packages.emit('snippets:loaded');
      return this.loaded = true;
    },
    loadSnippetsDirectory: function(snippetsDirPath, callback) {
      if (!fs.isDirectorySync(snippetsDirPath)) {
        return typeof callback === "function" ? callback() : void 0;
      }
      return fs.readdir(snippetsDirPath, (function(_this) {
        return function(error, entries) {
          var paths;
          if (error != null) {
            console.warn(error);
            return typeof callback === "function" ? callback() : void 0;
          } else {
            paths = entries.map(function(file) {
              return path.join(snippetsDirPath, file);
            });
            return async.eachSeries(paths, _this.loadSnippetsFile.bind(_this), callback);
          }
        };
      })(this));
    },
    loadSnippetsFile: function(filePath, callback) {
      if (!CSON.isObjectPath(filePath)) {
        return typeof callback === "function" ? callback() : void 0;
      }
      return CSON.readFile(filePath, (function(_this) {
        return function(error, object) {
          var _ref;
          if (object == null) {
            object = {};
          }
          if (error != null) {
            console.warn("Error reading snippets file '" + filePath + "': " + ((_ref = error.stack) != null ? _ref : error));
          } else {
            _this.add(filePath, object);
          }
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    },
    add: function(filePath, snippetsBySelector) {
      var attributes, body, bodyTree, name, prefix, selector, snippet, snippetsByName, snippetsByPrefix, _results;
      _results = [];
      for (selector in snippetsBySelector) {
        snippetsByName = snippetsBySelector[selector];
        snippetsByPrefix = {};
        for (name in snippetsByName) {
          attributes = snippetsByName[name];
          prefix = attributes.prefix, body = attributes.body, bodyTree = attributes.bodyTree;
          if (bodyTree == null) {
            bodyTree = this.getBodyParser().parse(body);
          }
          snippet = new Snippet({
            name: name,
            prefix: prefix,
            bodyTree: bodyTree,
            bodyText: body
          });
          snippetsByPrefix[snippet.prefix] = snippet;
        }
        _results.push(atom.syntax.addProperties(filePath, selector, {
          snippets: snippetsByPrefix
        }));
      }
      return _results;
    },
    getBodyParser: function() {
      return this.bodyParser != null ? this.bodyParser : this.bodyParser = require('./snippet-body-parser');
    },
    getPrefixText: function(snippets, editor) {
      var cursor, prefixStart, wordRegex;
      wordRegex = this.wordRegexForSnippets(snippets);
      cursor = editor.getCursor();
      prefixStart = cursor.getBeginningOfCurrentWordBufferPosition({
        wordRegex: wordRegex
      });
      return editor.getTextInRange([prefixStart, cursor.getBufferPosition()]);
    },
    enableSnippetsInEditor: function(editorView) {
      var editor;
      editor = editorView.getEditor();
      editorView.command('snippets:expand', (function(_this) {
        return function(event) {
          if (!_this.expandSnippetUnderCursor(editor)) {
            return event.abortKeyBinding();
          }
        };
      })(this));
      editorView.command('snippets:next-tab-stop', function(event) {
        var _ref;
        if (!((_ref = editor.snippetExpansion) != null ? _ref.goToNextTabStop() : void 0)) {
          return event.abortKeyBinding();
        }
      });
      return editorView.command('snippets:previous-tab-stop', function(event) {
        var _ref;
        if (!((_ref = editor.snippetExpansion) != null ? _ref.goToPreviousTabStop() : void 0)) {
          return event.abortKeyBinding();
        }
      });
    },
    wordRegexForSnippets: function(snippets) {
      var character, prefix, prefixCharacters, prefixes, _i, _len;
      prefixes = {};
      for (prefix in snippets) {
        for (_i = 0, _len = prefix.length; _i < _len; _i++) {
          character = prefix[_i];
          prefixes[character] = true;
        }
      }
      prefixCharacters = Object.keys(prefixes).join('');
      return new RegExp("[" + (_.escapeRegExp(prefixCharacters)) + "]+");
    },
    snippetForPrefix: function(snippets, prefix) {
      var longestPrefixMatch, snippet, snippetPrefix;
      longestPrefixMatch = null;
      for (snippetPrefix in snippets) {
        snippet = snippets[snippetPrefix];
        if (snippetPrefix === prefix) {
          longestPrefixMatch = snippet;
          break;
        } else if (_.endsWith(prefix, snippetPrefix)) {
          if (longestPrefixMatch == null) {
            longestPrefixMatch = snippet;
          }
          if (snippetPrefix.length > longestPrefixMatch.prefix.length) {
            longestPrefixMatch = snippet;
          }
        }
      }
      return longestPrefixMatch;
    },
    getSnippets: function(editor) {
      var properties, scope, snippet, snippetPrefix, snippetProperties, snippets, _i, _len, _ref, _ref1;
      scope = editor.getCursorScopes();
      snippets = {};
      _ref = atom.syntax.propertiesForScope(scope, 'snippets');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        properties = _ref[_i];
        snippetProperties = (_ref1 = _.valueForKeyPath(properties, 'snippets')) != null ? _ref1 : {};
        for (snippetPrefix in snippetProperties) {
          snippet = snippetProperties[snippetPrefix];
          if (snippets[snippetPrefix] == null) {
            snippets[snippetPrefix] = snippet;
          }
        }
      }
      return snippets;
    },
    expandSnippetUnderCursor: function(editor) {
      var prefix, snippet, snippets;
      if (!editor.getSelection().isEmpty()) {
        return false;
      }
      snippets = this.getSnippets(editor);
      if (_.isEmpty(snippets)) {
        return false;
      }
      prefix = this.getPrefixText(snippets, editor);
      if (!prefix) {
        return false;
      }
      snippet = this.snippetForPrefix(snippets, prefix);
      if (snippet == null) {
        return false;
      }
      editor.transact((function(_this) {
        return function() {
          var cursorPosition, startPoint;
          cursorPosition = editor.getCursorBufferPosition();
          startPoint = cursorPosition.translate([0, -snippet.prefix.length], [0, 0]);
          editor.setSelectedBufferRange([startPoint, cursorPosition]);
          return _this.insert(snippet, editor);
        };
      })(this));
      return true;
    },
    insert: function(snippet, editor) {
      var bodyTree;
      if (editor == null) {
        editor = atom.workspace.getActiveEditor();
      }
      if (typeof snippet === 'string') {
        bodyTree = this.getBodyParser().parse(snippet);
        snippet = new Snippet({
          name: '__anonymous',
          prefix: '',
          bodyTree: bodyTree,
          bodyText: snippet
        });
      }
      return new SnippetExpansion(snippet, editor);
    }
  };

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/snippets/lib/snippets.js.map
