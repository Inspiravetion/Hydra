(function() {
  var AtomModifiers, KeyboardEventModifiers, SpecificityCache, charCodeFromHexCharCode, fs, isAscii, keyFromCharCode, loophole, modifier, normalizeKeystroke, parseKeystroke, parser, pegjs, specificity, _i, _j, _len, _len1, _ref, _ref1, _ref2;

  specificity = require('clear-cut').specificity;

  _ref = [], parser = _ref[0], fs = _ref[1], loophole = _ref[2], pegjs = _ref[3];

  AtomModifiers = new Set;

  _ref1 = ['ctrl', 'alt', 'shift', 'cmd'];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    modifier = _ref1[_i];
    AtomModifiers.add(modifier);
  }

  KeyboardEventModifiers = new Set;

  _ref2 = ['Control', 'Alt', 'Shift', 'Meta'];
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    modifier = _ref2[_j];
    KeyboardEventModifiers.add(modifier);
  }

  SpecificityCache = {};

  exports.normalizeKeystrokes = function(keystrokes) {
    var keystroke, normalizedKeystroke, normalizedKeystrokes, _k, _len2, _ref3;
    normalizedKeystrokes = [];
    _ref3 = keystrokes.split(/\s+/);
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      keystroke = _ref3[_k];
      if (normalizedKeystroke = normalizeKeystroke(keystroke)) {
        normalizedKeystrokes.push(normalizedKeystroke);
      } else {
        return false;
      }
    }
    return normalizedKeystrokes.join(' ');
  };

  exports.keystrokeForKeyboardEvent = function(event) {
    var charCode, hexCharCode, key, keystroke;
    if (!KeyboardEventModifiers.has(event.keyIdentifier)) {
      if (event.keyIdentifier.indexOf('U+') === 0) {
        hexCharCode = event.keyIdentifier.slice(2);
        charCode = charCodeFromHexCharCode(hexCharCode);
        if (!isAscii(charCode) && isAscii(event.which)) {
          charCode = event.which;
        }
        key = keyFromCharCode(charCode);
      } else {
        key = event.keyIdentifier.toLowerCase();
      }
    }
    keystroke = [];
    if (event.ctrlKey) {
      keystroke.push('ctrl');
    }
    if (event.altKey) {
      keystroke.push('alt');
    }
    if (event.shiftKey) {
      if (!(/^[^A-Za-z]$/.test(key) && process.platform !== 'linux')) {
        keystroke.push('shift');
      }
      if (/^[a-z]$/.test(key)) {
        key = key.toUpperCase();
      }
    } else {
      if (/^[A-Z]$/.test(key)) {
        key = key.toLowerCase();
      }
    }
    if (event.metaKey) {
      keystroke.push('cmd');
    }
    if (key != null) {
      keystroke.push(key);
    }
    return keystroke.join('-');
  };

  exports.calculateSpecificity = function(selector) {
    return SpecificityCache[selector] != null ? SpecificityCache[selector] : SpecificityCache[selector] = specificity(selector);
  };

  exports.isAtomModifier = function(key) {
    return AtomModifiers.has(key);
  };

  exports.keydownEvent = function(key, _arg) {
    var alt, bubbles, cancelable, cmd, ctrl, event, keyIdentifier, location, shift, target, view, which, _ref3;
    _ref3 = _arg != null ? _arg : {}, ctrl = _ref3.ctrl, shift = _ref3.shift, alt = _ref3.alt, cmd = _ref3.cmd, which = _ref3.which, target = _ref3.target;
    event = document.createEvent('KeyboardEvent');
    bubbles = true;
    cancelable = true;
    view = null;
    if (/^[a-z]$/.test(key)) {
      key = key.toUpperCase();
    }
    if (key.length === 1) {
      keyIdentifier = "U+" + (key.charCodeAt(0).toString(16));
    } else {
      switch (key) {
        case 'ctrl':
          keyIdentifier = 'Control';
          ctrl = true;
          break;
        case 'alt':
          keyIdentifier = 'Alt';
          alt = true;
          break;
        case 'shift':
          keyIdentifier = 'Shift';
          shift = true;
          break;
        case 'cmd':
          keyIdentifier = 'Meta';
          cmd = true;
          break;
        default:
          keyIdentifier = key[0].toUpperCase() + key.slice(1);
      }
    }
    location = KeyboardEvent.DOM_KEY_LOCATION_STANDARD;
    event.initKeyboardEvent('keydown', bubbles, cancelable, view, keyIdentifier, location, ctrl, alt, shift, cmd);
    if (target != null) {
      Object.defineProperty(event, 'target', {
        get: function() {
          return target;
        }
      });
    }
    if (which != null) {
      Object.defineProperty(event, 'which', {
        get: function() {
          return which;
        }
      });
    }
    return event;
  };

  normalizeKeystroke = function(keystroke) {
    var i, key, keys, modifiers, primaryKey, _k, _len2;
    keys = parseKeystroke(keystroke);
    primaryKey = null;
    modifiers = new Set;
    for (i = _k = 0, _len2 = keys.length; _k < _len2; i = ++_k) {
      key = keys[i];
      if (AtomModifiers.has(key)) {
        modifiers.add(key);
      } else {
        if (i === keys.length - 1) {
          primaryKey = key;
        } else {
          return false;
        }
      }
    }
    if (/^[A-Z]$/.test(primaryKey)) {
      modifiers.add('shift');
    }
    if (modifiers.has('shift') && /^[a-z]$/.test(primaryKey)) {
      primaryKey = primaryKey.toUpperCase();
    }
    keystroke = [];
    if (modifiers.has('ctrl')) {
      keystroke.push('ctrl');
    }
    if (modifiers.has('alt')) {
      keystroke.push('alt');
    }
    if (modifiers.has('shift')) {
      keystroke.push('shift');
    }
    if (modifiers.has('cmd')) {
      keystroke.push('cmd');
    }
    if (primaryKey != null) {
      keystroke.push(primaryKey);
    }
    return keystroke.join('-');
  };

  parseKeystroke = function(keystroke) {
    var e, keystrokeGrammar;
    if (parser == null) {
      try {
        parser = require('./keystroke');
      } catch (_error) {
        e = _error;
        if (fs == null) {
          fs = require('fs');
        }
        if (loophole == null) {
          loophole = require('loophole');
        }
        if (pegjs == null) {
          pegjs = require('pegjs');
        }
        keystrokeGrammar = fs.readFileSync(require.resolve('./keystroke.pegjs'), 'utf8');
        loophole.allowUnsafeEval((function(_this) {
          return function() {
            return parser = pegjs.buildParser(keystrokeGrammar);
          };
        })(this));
      }
    }
    return parser.parse(keystroke);
  };

  charCodeFromHexCharCode = function(hexCharCode) {
    var charCode;
    charCode = parseInt(hexCharCode, 16);
    if (process.platform === 'linux') {
      switch (charCode) {
        case 186:
          charCode = 59;
          break;
        case 187:
          charCode = 61;
          break;
        case 188:
          charCode = 44;
          break;
        case 189:
          charCode = 45;
          break;
        case 190:
          charCode = 46;
          break;
        case 191:
          charCode = 47;
          break;
        case 219:
          charCode = 91;
          break;
        case 220:
          charCode = 92;
          break;
        case 221:
          charCode = 93;
          break;
        case 222:
          charCode = 39;
      }
    }
    return charCode;
  };

  keyFromCharCode = function(charCode) {
    switch (charCode) {
      case 8:
        return 'backspace';
      case 9:
        return 'tab';
      case 13:
        return 'enter';
      case 27:
        return 'escape';
      case 32:
        return 'space';
      case 127:
        return 'delete';
      default:
        return String.fromCharCode(charCode);
    }
  };

  isAscii = function(charCode) {
    return (0 <= charCode && charCode <= 127);
  };

}).call(this);
