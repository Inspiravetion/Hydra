(function() {
  var CSON, CommandEvent, Emitter, File, KeyBinding, KeymapManager, OtherPlatforms, Platforms, fs, isAtomModifier, keydownEvent, keystrokeForKeyboardEvent, normalizeKeystrokes, path, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("underscore-plus");

  CSON = require('season');

  fs = require('fs-plus');

  path = require('path');

  Emitter = require('emissary').Emitter;

  File = require('pathwatcher').File;

  KeyBinding = require('./key-binding');

  CommandEvent = require('./command-event');

  _ref = require('./helpers'), normalizeKeystrokes = _ref.normalizeKeystrokes, keystrokeForKeyboardEvent = _ref.keystrokeForKeyboardEvent, isAtomModifier = _ref.isAtomModifier, keydownEvent = _ref.keydownEvent;

  Platforms = ['darwin', 'freebsd', 'linux', 'sunos', 'win32'];

  OtherPlatforms = Platforms.filter(function(platform) {
    return platform !== process.platform;
  });

  module.exports = KeymapManager = (function() {
    Emitter.includeInto(KeymapManager);

    KeymapManager.keydownEvent = function(key, options) {
      return keydownEvent(key, options);
    };

    KeymapManager.prototype.partialMatchTimeout = 1000;

    KeymapManager.prototype.defaultTarget = null;

    KeymapManager.prototype.pendingPartialMatches = null;

    KeymapManager.prototype.pendingStateTimeoutHandle = null;

    function KeymapManager(options) {
      var key, value;
      if (options == null) {
        options = {};
      }
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.keyBindings = [];
      this.queuedKeyboardEvents = [];
      this.queuedKeystrokes = [];
      this.watchSubscriptions = {};
    }

    KeymapManager.prototype.destroy = function() {
      var filePath, subscription, _ref1, _results;
      _ref1 = this.watchSubscriptions;
      _results = [];
      for (filePath in _ref1) {
        subscription = _ref1[filePath];
        _results.push(subscription.off());
      }
      return _results;
    };

    KeymapManager.prototype.getKeyBindings = function() {
      return this.keyBindings.slice();
    };

    KeymapManager.prototype.addKeymap = function(source, keyBindingsBySelector) {
      var command, e, keyBinding, keyBindings, keystrokes, normalizedKeystrokes, selector;
      for (selector in keyBindingsBySelector) {
        keyBindings = keyBindingsBySelector[selector];
        try {
          document.body.webkitMatchesSelector(selector.replace(/!important/g, ''));
        } catch (_error) {
          e = _error;
          console.warn("Encountered an invalid selector adding key bindings from '" + source + "': '" + selector + "'");
          return;
        }
        for (keystrokes in keyBindings) {
          command = keyBindings[keystrokes];
          if (normalizedKeystrokes = normalizeKeystrokes(keystrokes)) {
            keyBinding = new KeyBinding(source, command, normalizedKeystrokes, selector);
            this.keyBindings.push(keyBinding);
          } else {
            console.warn("Invalid keystroke sequence for binding: `" + keystrokes + ": " + command + "` in " + source);
          }
        }
      }
    };

    KeymapManager.prototype.loadKeymap = function(bindingsPath, options) {
      var checkIfDirectory, filePath, _i, _len, _ref1, _ref2, _results;
      checkIfDirectory = (_ref1 = options != null ? options.checkIfDirectory : void 0) != null ? _ref1 : true;
      if (checkIfDirectory && fs.isDirectorySync(bindingsPath)) {
        _ref2 = fs.listSync(bindingsPath, ['.cson', '.json']);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          filePath = _ref2[_i];
          if (this.filePathMatchesPlatform(filePath)) {
            _results.push(this.loadKeymap(filePath, {
              checkIfDirectory: false
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else {
        this.addKeymap(bindingsPath, this.readKeymap(bindingsPath, options != null ? options.suppressErrors : void 0));
        if (options != null ? options.watch : void 0) {
          return this.watchKeymap(bindingsPath);
        }
      }
    };

    KeymapManager.prototype.watchKeymap = function(filePath) {
      var _ref1;
      if (((_ref1 = this.watchSubscriptions[filePath]) != null ? _ref1.cancelled : void 0) !== false) {
        return this.watchSubscriptions[filePath] = new File(filePath).on('contents-changed moved removed', (function(_this) {
          return function() {
            return _this.reloadKeymap(filePath);
          };
        })(this));
      }
    };

    KeymapManager.prototype.removeKeymap = function(source) {
      return this.keyBindings = this.keyBindings.filter(function(keyBinding) {
        return keyBinding.source !== source;
      });
    };

    KeymapManager.prototype.handleKeyboardEvent = function(event, replaying) {
      var currentTarget, enableTimeout, exactMatch, exactMatchCandidates, exactMatches, foundMatch, keystroke, keystrokes, partialMatchCandidates, partialMatches, target, _i, _len, _ref1;
      keystroke = this.keystrokeForKeyboardEvent(event);
      if (this.queuedKeystrokes.length > 0 && isAtomModifier(keystroke)) {
        event.preventDefault();
        return;
      }
      this.queuedKeyboardEvents.push(event);
      this.queuedKeystrokes.push(keystroke);
      keystrokes = this.queuedKeystrokes.join(' ');
      target = event.target;
      if (event.target === document.body && (this.defaultTarget != null)) {
        target = this.defaultTarget;
      }
      _ref1 = this.findMatchCandidates(keystrokes), partialMatchCandidates = _ref1.partialMatchCandidates, exactMatchCandidates = _ref1.exactMatchCandidates;
      partialMatches = this.findPartialMatches(partialMatchCandidates, target);
      if (exactMatchCandidates.length > 0) {
        currentTarget = target;
        while ((currentTarget != null) && currentTarget !== document) {
          exactMatches = this.findExactMatches(exactMatchCandidates, currentTarget);
          for (_i = 0, _len = exactMatches.length; _i < _len; _i++) {
            exactMatch = exactMatches[_i];
            if (exactMatch.command === 'native!') {
              this.clearQueuedKeystrokes();
              return;
            }
            if (exactMatch.command === 'unset!') {
              break;
            }
            foundMatch = true;
            if (partialMatches.length > 0) {
              break;
            }
            this.clearQueuedKeystrokes();
            this.cancelPendingState();
            if (this.dispatchCommandEvent(exactMatch.command, target, event)) {
              this.emit('matched', {
                keystrokes: keystrokes,
                binding: exactMatch,
                keyboardEventTarget: target
              });
              return;
            }
          }
          currentTarget = currentTarget.parentElement;
        }
      }
      if (partialMatches.length > 0) {
        event.preventDefault();
        enableTimeout = foundMatch != null ? foundMatch : this.pendingStateTimeoutHandle != null;
        this.enterPendingState(partialMatches, enableTimeout);
        return this.emit('matched-partially', {
          keystrokes: keystrokes,
          partiallyMatchedBindings: partialMatches,
          keyboardEventTarget: target
        });
      } else {
        this.emit('match-failed', {
          keystrokes: keystrokes,
          keyboardEventTarget: target
        });
        return this.terminatePendingState();
      }
    };

    KeymapManager.prototype.findKeyBindings = function(params) {
      var bindings, candidateBindings, command, element, keyBindings, keystrokes, matchingBindings, target;
      if (params == null) {
        params = {};
      }
      keystrokes = params.keystrokes, command = params.command, target = params.target, keyBindings = params.keyBindings;
      bindings = keyBindings != null ? keyBindings : this.keyBindings;
      if (command != null) {
        bindings = bindings.filter(function(binding) {
          return binding.command === command;
        });
      }
      if (keystrokes != null) {
        bindings = bindings.filter(function(binding) {
          return binding.keystrokes === keystrokes;
        });
      }
      if (target != null) {
        candidateBindings = bindings;
        bindings = [];
        element = target;
        while ((element != null) && element !== document) {
          matchingBindings = candidateBindings.filter(function(binding) {
            return element.webkitMatchesSelector(binding.selector);
          }).sort(function(a, b) {
            return a.compare(b);
          });
          bindings.push.apply(bindings, matchingBindings);
          element = element.parentElement;
        }
      }
      return bindings;
    };

    KeymapManager.prototype.reloadKeymap = function(filePath) {
      var bindings;
      if (fs.isFileSync(filePath)) {
        if (bindings = this.readKeymap(filePath, true)) {
          this.removeKeymap(filePath);
          this.addKeymap(filePath, bindings);
          return this.emit('reloaded-key-bindings', filePath);
        }
      } else {
        this.removeKeymap(filePath);
        return this.emit('unloaded-key-bindings', filePath);
      }
    };

    KeymapManager.prototype.readKeymap = function(filePath, suppressErrors) {
      var error, _ref1;
      if (suppressErrors) {
        try {
          return CSON.readFileSync(filePath);
        } catch (_error) {
          error = _error;
          console.warn("Failed to reload key bindings file: " + filePath, (_ref1 = error.stack) != null ? _ref1 : error);
          return void 0;
        }
      } else {
        return CSON.readFileSync(filePath);
      }
    };

    KeymapManager.prototype.filePathMatchesPlatform = function(filePath) {
      var component, otherPlatforms, _i, _len, _ref1;
      otherPlatforms = this.getOtherPlatforms();
      _ref1 = path.basename(filePath).split('.').slice(0, -1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        component = _ref1[_i];
        if (__indexOf.call(otherPlatforms, component) >= 0) {
          return false;
        }
      }
      return true;
    };

    KeymapManager.prototype.getOtherPlatforms = function() {
      return OtherPlatforms;
    };

    KeymapManager.prototype.findMatchCandidates = function(keystrokes) {
      var binding, exactMatchCandidates, keystrokesWithSpace, partialMatchCandidates, _i, _len, _ref1;
      partialMatchCandidates = [];
      exactMatchCandidates = [];
      keystrokesWithSpace = keystrokes + ' ';
      _ref1 = this.keyBindings;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        binding = _ref1[_i];
        if (binding.enabled) {
          if (binding.keystrokes === keystrokes) {
            exactMatchCandidates.push(binding);
          } else if (binding.keystrokes.indexOf(keystrokesWithSpace) === 0) {
            partialMatchCandidates.push(binding);
          }
        }
      }
      return {
        partialMatchCandidates: partialMatchCandidates,
        exactMatchCandidates: exactMatchCandidates
      };
    };

    KeymapManager.prototype.findPartialMatches = function(partialMatchCandidates, target) {
      var partialMatches;
      partialMatches = [];
      while (partialMatchCandidates.length > 0 && (target != null) && target !== document) {
        partialMatchCandidates = partialMatchCandidates.filter(function(binding) {
          if (target.webkitMatchesSelector(binding.selector)) {
            partialMatches.push(binding);
            return false;
          } else {
            return true;
          }
        });
        target = target.parentElement;
      }
      return partialMatches.sort(function(a, b) {
        return b.keystrokeCount - a.keystrokeCount;
      });
    };

    KeymapManager.prototype.findExactMatches = function(exactMatchCandidates, target) {
      var exactMatches;
      return exactMatches = exactMatchCandidates.filter(function(binding) {
        return target.webkitMatchesSelector(binding.selector);
      }).sort(function(a, b) {
        return a.compare(b);
      });
    };

    KeymapManager.prototype.clearQueuedKeystrokes = function() {
      this.queuedKeyboardEvents = [];
      return this.queuedKeystrokes = [];
    };

    KeymapManager.prototype.enterPendingState = function(pendingPartialMatches, enableTimeout) {
      if (this.pendingStateTimeoutHandle != null) {
        this.cancelPendingState();
      }
      this.pendingPartialMatches = pendingPartialMatches;
      if (enableTimeout) {
        return this.pendingStateTimeoutHandle = setTimeout(this.terminatePendingState.bind(this), this.partialMatchTimeout);
      }
    };

    KeymapManager.prototype.cancelPendingState = function() {
      clearTimeout(this.pendingStateTimeoutHandle);
      this.pendingStateTimeoutHandle = null;
      return this.pendingPartialMatches = null;
    };

    KeymapManager.prototype.terminatePendingState = function() {
      var binding, bindingsToDisable, event, eventsToReplay, _i, _j, _k, _len, _len1, _len2, _results;
      if (this.pendingPartialMatches == null) {
        this.clearQueuedKeystrokes();
        return;
      }
      bindingsToDisable = this.pendingPartialMatches;
      eventsToReplay = this.queuedKeyboardEvents;
      this.cancelPendingState();
      this.clearQueuedKeystrokes();
      for (_i = 0, _len = bindingsToDisable.length; _i < _len; _i++) {
        binding = bindingsToDisable[_i];
        binding.enabled = false;
      }
      for (_j = 0, _len1 = eventsToReplay.length; _j < _len1; _j++) {
        event = eventsToReplay[_j];
        this.handleKeyboardEvent(event, true);
      }
      _results = [];
      for (_k = 0, _len2 = bindingsToDisable.length; _k < _len2; _k++) {
        binding = bindingsToDisable[_k];
        _results.push(binding.enabled = true);
      }
      return _results;
    };

    KeymapManager.prototype.dispatchCommandEvent = function(command, target, keyboardEvent) {
      var commandEvent;
      keyboardEvent.preventDefault();
      commandEvent = new CustomEvent(command, {
        bubbles: true,
        cancelable: true
      });
      commandEvent.__proto__ = CommandEvent.prototype;
      commandEvent.originalEvent = keyboardEvent;
      if (document.contains(target)) {
        target.dispatchEvent(commandEvent);
      } else {
        this.simulateBubblingOnDetachedTarget(target, commandEvent);
      }
      return !commandEvent.keyBindingAborted;
    };

    KeymapManager.prototype.simulateBubblingOnDetachedTarget = function(target, commandEvent) {
      var currentTarget, _results;
      Object.defineProperty(commandEvent, 'target', {
        get: function() {
          return target;
        }
      });
      Object.defineProperty(commandEvent, 'currentTarget', {
        get: function() {
          return currentTarget;
        }
      });
      currentTarget = target;
      _results = [];
      while (currentTarget != null) {
        currentTarget.dispatchEvent(commandEvent);
        if (commandEvent.propagationStopped) {
          break;
        }
        _results.push(currentTarget = currentTarget.parentElement);
      }
      return _results;
    };

    KeymapManager.prototype.keystrokeForKeyboardEvent = function(event) {
      return keystrokeForKeyboardEvent(event);
    };

    KeymapManager.prototype.add = function(source, bindings) {
      return this.addKeymap(source, bindings);
    };

    KeymapManager.prototype.remove = function(source) {
      return this.removeKeymap(source);
    };

    KeymapManager.prototype.handleKeyEvent = function(event) {
      var originalEvent, _ref1;
      originalEvent = (_ref1 = event.originalEvent) != null ? _ref1 : event;
      if (originalEvent.target == null) {
        Object.defineProperty(originalEvent, 'target', {
          get: function() {
            return event.target;
          }
        });
      }
      this.handleKeyboardEvent(originalEvent);
      return !originalEvent.defaultPrevented;
    };

    KeymapManager.prototype.keystrokeStringForEvent = function(event) {
      var _ref1;
      return this.keystrokeForKeyboardEvent((_ref1 = event.originalEvent) != null ? _ref1 : event);
    };

    KeymapManager.prototype.bindKeys = function(source, selector, keyBindings) {
      var keyBindingsBySelector;
      keyBindingsBySelector = {};
      keyBindingsBySelector[selector] = keyBindings;
      return this.addKeymap(source, keyBindingsBySelector);
    };

    KeymapManager.prototype.keyBindingsForCommand = function(command) {
      return this.findKeyBindings({
        command: command
      });
    };

    KeymapManager.prototype.keyBindingsForKeystroke = function(keystroke) {
      return this.findKeyBindings({
        keystrokes: keystroke
      });
    };

    KeymapManager.prototype.keyBindingsMatchingElement = function(target, keyBindings) {
      var _ref1;
      return this.findKeyBindings({
        target: (_ref1 = target[0]) != null ? _ref1 : target,
        keyBindings: keyBindings
      });
    };

    KeymapManager.prototype.keyBindingsForCommandMatchingElement = function(command, target) {
      var _ref1;
      return this.findKeyBindings({
        command: command,
        target: (_ref1 = target[0]) != null ? _ref1 : target
      });
    };

    KeymapManager.prototype.keyBindingsForKeystrokeMatchingElement = function(keystrokes, target) {
      var _ref1;
      return this.findKeyBindings({
        keystrokes: keystrokes,
        target: (_ref1 = target[0]) != null ? _ref1 : target
      });
    };

    return KeymapManager;

  })();

}).call(this);
