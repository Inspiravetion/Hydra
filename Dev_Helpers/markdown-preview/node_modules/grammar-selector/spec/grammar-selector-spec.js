(function() {
  var $, StatusBarMock, View, WorkspaceView, path, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require('path');

  _ref = require('atom'), $ = _ref.$, WorkspaceView = _ref.WorkspaceView, View = _ref.View;

  StatusBarMock = (function(_super) {
    __extends(StatusBarMock, _super);

    function StatusBarMock() {
      return StatusBarMock.__super__.constructor.apply(this, arguments);
    }

    StatusBarMock.content = function() {
      return this.div({
        "class": 'status-bar tool-panel panel-bottom'
      }, (function(_this) {
        return function() {
          return _this.div({
            outlet: 'leftPanel',
            "class": 'status-bar-left'
          });
        };
      })(this));
    };

    StatusBarMock.prototype.attach = function() {
      return atom.workspaceView.appendToTop(this);
    };

    StatusBarMock.prototype.appendLeft = function(item) {
      return this.leftPanel.append(item);
    };

    return StatusBarMock;

  })(View);

  describe("GrammarSelector", function() {
    var editor, editorView, jsGrammar, textGrammar, _ref1;
    _ref1 = [], editor = _ref1[0], editorView = _ref1[1], textGrammar = _ref1[2], jsGrammar = _ref1[3];
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspace = atom.workspaceView.model;
      waitsForPromise(function() {
        return atom.packages.activatePackage('grammar-selector');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-text');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage(path.join(__dirname, 'fixtures', 'language-with-no-name'));
      });
      return runs(function() {
        atom.workspaceView.openSync('sample.js');
        editorView = atom.workspaceView.getActiveView();
        editor = editorView.editor;
        textGrammar = atom.syntax.grammarForScopeName('text.plain');
        expect(textGrammar).toBeTruthy();
        jsGrammar = atom.syntax.grammarForScopeName('source.js');
        expect(jsGrammar).toBeTruthy();
        return expect(editor.getGrammar()).toBe(jsGrammar);
      });
    });
    describe("when grammar-selector:show is triggered", function() {
      return it("displays a list of all the available grammars", function() {
        var grammarView, grammars, li, _i, _len, _ref2, _results;
        editorView.trigger('grammar-selector:show');
        grammarView = atom.workspaceView.find('.grammar-selector').view();
        expect(grammarView).toExist();
        grammars = atom.syntax.grammars;
        expect(grammarView.list.children('li').length).toBe(grammars.length);
        expect(grammarView.list.children('li:first').text()).toBe('Auto Detect');
        expect(grammarView.list.children('li:contains(source.a)')).toExist();
        _ref2 = grammarView.list.children('li');
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          li = _ref2[_i];
          _results.push(expect($(li).text()).not.toBe(atom.syntax.nullGrammar.name));
        }
        return _results;
      });
    });
    describe("when a grammar is selected", function() {
      return it("sets the new grammar on the editor", function() {
        var grammarView;
        editorView.trigger('grammar-selector:show');
        grammarView = atom.workspaceView.find('.grammar-selector').view();
        grammarView.confirmed(textGrammar);
        return expect(editor.getGrammar()).toBe(textGrammar);
      });
    });
    describe("when auto-detect is selected", function() {
      return it("restores the auto-detected grammar on the editor", function() {
        var grammarView;
        editorView.trigger('grammar-selector:show');
        grammarView = atom.workspaceView.find('.grammar-selector').view();
        grammarView.confirmed(textGrammar);
        expect(editor.getGrammar()).toBe(textGrammar);
        editorView.trigger('grammar-selector:show');
        grammarView = atom.workspaceView.find('.grammar-selector').view();
        grammarView.confirmed(grammarView.items[0]);
        return expect(editor.getGrammar()).toBe(jsGrammar);
      });
    });
    describe("when the editor's current grammar is the null grammar", function() {
      return it("displays Auto Detect as the selected grammar", function() {
        var grammarView;
        editor.setGrammar(atom.syntax.nullGrammar);
        editorView.trigger('grammar-selector:show');
        grammarView = atom.workspaceView.find('.grammar-selector').view();
        return expect(grammarView.list.children('li.active').text()).toBe('Auto Detect');
      });
    });
    describe("when editor is untitled", function() {
      return it("sets the new grammar on the editor", function() {
        waitsForPromise(function() {
          return atom.workspace.open();
        });
        return runs(function() {
          var grammarView;
          editorView = atom.workspaceView.getActiveView();
          editor = editorView.editor;
          editorView.trigger('grammar-selector:show');
          expect(editor.getGrammar()).not.toBe(jsGrammar);
          grammarView = atom.workspaceView.find('.grammar-selector').view();
          grammarView.confirmed(jsGrammar);
          return expect(editor.getGrammar()).toBe(jsGrammar);
        });
      });
    });
    return describe("grammar label", function() {
      var grammarStatus;
      grammarStatus = [][0];
      beforeEach(function() {
        atom.workspaceView.statusBar = new StatusBarMock();
        atom.workspaceView.statusBar.attach();
        atom.packages.emit('activated');
        grammarStatus = atom.workspaceView.statusBar.leftPanel.children().view();
        return expect(grammarStatus).toExist();
      });
      afterEach(function() {
        atom.workspaceView.statusBar.remove();
        return atom.workspaceView.statusBar = null;
      });
      it("displays the name of the current grammar", function() {
        return expect(grammarStatus.text()).toBe('JavaScript');
      });
      it("displays Plain Text when the current grammar is the null grammar", function() {
        atom.workspaceView.attachToDom();
        editor.setGrammar(atom.syntax.nullGrammar);
        expect(grammarStatus).toBeVisible();
        expect(grammarStatus.text()).toBe('Plain Text');
        editor.reloadGrammar();
        expect(grammarStatus).toBeVisible();
        return expect(grammarStatus.text()).toBe('JavaScript');
      });
      it("hides the label when the current grammar is null", function() {
        atom.workspaceView.attachToDom();
        spyOn(editor, 'getGrammar').andReturn(null);
        editor.setGrammar(atom.syntax.nullGrammar);
        return expect(grammarStatus).toBeHidden();
      });
      describe("when the editor's grammar changes", function() {
        return it("displays the new grammar of the editor", function() {
          atom.syntax.setGrammarOverrideForPath(editor.getPath(), 'text.plain');
          editor.reloadGrammar();
          expect(grammarStatus.text()).toBe('Plain Text');
          atom.syntax.setGrammarOverrideForPath(editor.getPath(), 'source.a');
          editor.reloadGrammar();
          return expect(grammarStatus.text()).toBe('source.a');
        });
      });
      return describe("when clicked", function() {
        return it("toggles the grammar-selector:show event", function() {
          var eventHandler;
          eventHandler = jasmine.createSpy('eventHandler');
          atom.workspaceView.on('grammar-selector:show', eventHandler);
          grammarStatus.click();
          return expect(eventHandler).toHaveBeenCalled();
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/grammar-selector/spec/grammar-selector-spec.js.map
