(function() {
  var $, CSON, PackageManager, Q, ThemesPanel, path;

  path = require('path');

  $ = require('atom').$;

  CSON = require('season');

  Q = require('q');

  PackageManager = require('../lib/package-manager');

  ThemesPanel = require('../lib/themes-panel');

  describe("ThemesPanel", function() {
    var packageManager, panel, reloadedHandler, _ref;
    _ref = [], panel = _ref[0], packageManager = _ref[1], reloadedHandler = _ref[2];
    beforeEach(function() {
      atom.packages.loadPackage('atom-light-ui');
      atom.packages.loadPackage('atom-dark-ui');
      atom.packages.loadPackage('atom-light-syntax');
      atom.packages.loadPackage('atom-dark-syntax');
      atom.packages.packageDirPaths.push(path.join(__dirname, 'fixtures'));
      atom.config.set('core.themes', ['atom-dark-ui', 'atom-dark-syntax']);
      reloadedHandler = jasmine.createSpy('reloadedHandler');
      atom.themes.on('reloaded', reloadedHandler);
      atom.themes.activatePackages();
      waitsFor(function() {
        return reloadedHandler.callCount === 1;
      });
      return runs(function() {
        var themeMetadata;
        packageManager = new PackageManager;
        themeMetadata = CSON.readFileSync(path.join(__dirname, 'fixtures', 'a-theme', 'package.json'));
        spyOn(packageManager, 'getFeatured').andCallFake(function(callback) {
          return Q([themeMetadata]);
        });
        spyOn(atom.themes, 'setEnabledThemes').andCallThrough();
        return panel = new ThemesPanel(packageManager);
      });
    });
    afterEach(function() {
      if (atom.packages.isPackageLoaded('a-theme')) {
        atom.packages.unloadPackage('a-theme');
      }
      return atom.themes.deactivateThemes();
    });
    it("selects the active syntax and UI themes", function() {
      expect(panel.uiMenu.val()).toBe('atom-dark-ui');
      return expect(panel.syntaxMenu.val()).toBe('atom-dark-syntax');
    });
    describe("when a UI theme is selected", function() {
      return it("updates the 'core.themes' config key with the selected UI theme", function() {
        jasmine.unspy(window, 'setTimeout');
        panel.uiMenu.val('atom-light-ui').trigger('change');
        waitsFor(function() {
          return atom.themes.setEnabledThemes.callCount > 0;
        });
        return runs(function() {
          return expect(atom.config.get('core.themes')).toEqual(['atom-light-ui', 'atom-dark-syntax']);
        });
      });
    });
    describe("when a syntax theme is selected", function() {
      return it("updates the 'core.themes' config key with the selected syntax theme", function() {
        jasmine.unspy(window, 'setTimeout');
        panel.syntaxMenu.val('atom-light-syntax').trigger('change');
        waitsFor(function() {
          return atom.themes.setEnabledThemes.callCount > 0;
        });
        return runs(function() {
          return expect(atom.config.get('core.themes')).toEqual(['atom-dark-ui', 'atom-light-syntax']);
        });
      });
    });
    describe("when the 'core.config' key is changes", function() {
      return it("refreshes the theme menus", function() {
        reloadedHandler.reset();
        atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax']);
        waitsFor(function() {
          return reloadedHandler.callCount === 1;
        });
        return runs(function() {
          expect(panel.uiMenu.val()).toBe('atom-light-ui');
          return expect(panel.syntaxMenu.val()).toBe('atom-light-syntax');
        });
      });
    });
    describe("when a theme is installed", function() {
      return it("adds it to the menu", function() {
        var themeView;
        expect(panel.syntaxMenu.find('option[value=a-theme]').length).toBe(0);
        themeView = null;
        waitsFor(function() {
          themeView = panel.find('.available-package-view').view();
          return themeView != null;
        });
        runs(function() {
          spyOn(packageManager, 'runCommand').andCallFake(function(args, callback) {
            return process.nextTick(function() {
              return callback(0);
            });
          });
          themeView.installButton.click();
          return expect(themeView.installButton.prop('disabled')).toBe(true);
        });
        waitsFor(function() {
          return panel.syntaxMenu.find('option[value=a-theme]').length === 1;
        });
        return runs(function() {
          expect(themeView.status).toHaveClass('icon-check');
          return expect(themeView.installButton.prop('disabled')).toBe(true);
        });
      });
    });
    return describe("when a theme fails to install", function() {
      return it("displays an error", function() {
        var themeView;
        expect(panel.syntaxMenu.find('option[value=a-theme]').length).toBe(0);
        themeView = null;
        waitsFor(function() {
          themeView = panel.find('.available-package-view').view();
          return themeView != null;
        });
        runs(function() {
          spyOn(console, 'error');
          spyOn(packageManager, 'runCommand').andCallFake(function(args, callback) {
            return process.nextTick(function() {
              return callback(-1, 'failed', 'failed');
            });
          });
          themeView.installButton.click();
          return expect(themeView.installButton.prop('disabled')).toBe(true);
        });
        waitsFor(function() {
          return themeView.status.hasClass('icon-alert');
        });
        return runs(function() {
          expect(console.error).toHaveBeenCalled();
          expect(themeView.installButton.prop('disabled')).toBe(false);
          return expect(panel.syntaxMenu.find('option[value=a-theme]').length).toBe(0);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/settings-view/spec/themes-panel-spec.js.map
