(function() {
  var $$$, PackageGrammarsView, View, path, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require('path');

  _ref = require('atom'), $$$ = _ref.$$$, View = _ref.View;

  module.exports = PackageGrammarsView = (function(_super) {
    __extends(PackageGrammarsView, _super);

    function PackageGrammarsView() {
      return PackageGrammarsView.__super__.constructor.apply(this, arguments);
    }

    PackageGrammarsView.content = function() {
      return this.section((function(_this) {
        return function() {
          _this.div({
            "class": 'section-heading icon icon-puzzle'
          }, 'Grammars');
          return _this.table({
            "class": 'package-grammars-table table native-key-bindings text',
            tabindex: -1
          }, function() {
            _this.thead(function() {
              return _this.tr(function() {
                _this.th('Name');
                _this.th('File Types');
                return _this.th('Scope');
              });
            });
            return _this.tbody({
              outlet: 'grammarItems'
            });
          });
        };
      })(this));
    };

    PackageGrammarsView.prototype.initialize = function(packagePath) {
      this.packagePath = path.join(packagePath, path.sep);
      this.addGrammars();
      return this.subscribe(atom.syntax, 'grammar-added grammar-updated', (function(_this) {
        return function() {
          return _this.addGrammars();
        };
      })(this));
    };

    PackageGrammarsView.prototype.getPackageGrammars = function() {
      var grammar, grammars, packageGrammars, _i, _len, _ref1;
      packageGrammars = [];
      grammars = (_ref1 = atom.syntax.grammars) != null ? _ref1 : [];
      for (_i = 0, _len = grammars.length; _i < _len; _i++) {
        grammar = grammars[_i];
        if (grammar.path) {
          if (grammar.path.indexOf(this.packagePath) === 0) {
            packageGrammars.push(grammar);
          }
        }
      }
      return packageGrammars;
    };

    PackageGrammarsView.prototype.addGrammars = function() {
      var fileTypes, name, scopeName, _i, _len, _ref1, _ref2;
      this.grammarItems.empty();
      _ref1 = this.getPackageGrammars();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], name = _ref2.name, fileTypes = _ref2.fileTypes, scopeName = _ref2.scopeName;
        this.grammarItems.append($$$(function() {
          return this.tr((function(_this) {
            return function() {
              var _ref3;
              _this.td(name != null ? name : '');
              _this.td((_ref3 = fileTypes != null ? fileTypes.join(', ') : void 0) != null ? _ref3 : '');
              return _this.td(scopeName != null ? scopeName : '');
            };
          })(this));
        }));
      }
      if (this.grammarItems.children().length > 0) {
        return this.show();
      } else {
        return this.hide();
      }
    };

    return PackageGrammarsView;

  })(View);

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/settings-view/lib/package-grammars-view.js.map
