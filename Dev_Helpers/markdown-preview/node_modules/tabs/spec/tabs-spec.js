(function() {
  var $, TabBarView, TabView, View, WorkspaceView, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('atom'), $ = _ref.$, WorkspaceView = _ref.WorkspaceView, View = _ref.View;

  _ = require('underscore-plus');

  TabBarView = require('../lib/tab-bar-view');

  TabView = require('../lib/tab-view');

  describe("Tabs package main", function() {
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.openSync('sample.js');
      return waitsForPromise(function() {
        return atom.packages.activatePackage("tabs");
      });
    });
    describe(".activate()", function() {
      return it("appends a tab bar all existing and new panes", function() {
        var pane;
        expect(atom.workspaceView.panes.find('.pane').length).toBe(1);
        expect(atom.workspaceView.panes.find('.pane > .tab-bar').length).toBe(1);
        pane = atom.workspaceView.getActivePane();
        pane.splitRight(pane.copyActiveItem());
        expect(atom.workspaceView.find('.pane').length).toBe(2);
        return expect(atom.workspaceView.panes.find('.pane > .tab-bar').length).toBe(2);
      });
    });
    return describe(".deactivate()", function() {
      return it("removes all tab bar views and stops adding them to new panes", function() {
        var pane;
        pane = atom.workspaceView.getActivePane();
        pane.splitRight(pane.copyActiveItem());
        expect(atom.workspaceView.panes.find('.pane').length).toBe(2);
        expect(atom.workspaceView.panes.find('.pane > .tab-bar').length).toBe(2);
        atom.packages.deactivatePackage('tabs');
        expect(atom.workspaceView.panes.find('.pane').length).toBe(2);
        expect(atom.workspaceView.panes.find('.pane > .tab-bar').length).toBe(0);
        pane.splitRight(pane.copyActiveItem());
        expect(atom.workspaceView.panes.find('.pane').length).toBe(3);
        return expect(atom.workspaceView.panes.find('.pane > .tab-bar').length).toBe(0);
      });
    });
  });

  describe("TabBarView", function() {
    var TestView, editor1, item1, item2, pane, tabBar, _ref1;
    _ref1 = [], item1 = _ref1[0], item2 = _ref1[1], editor1 = _ref1[2], pane = _ref1[3], tabBar = _ref1[4];
    TestView = (function(_super) {
      __extends(TestView, _super);

      function TestView() {
        return TestView.__super__.constructor.apply(this, arguments);
      }

      TestView.deserialize = function(_arg) {
        var longTitle, title;
        title = _arg.title, longTitle = _arg.longTitle;
        return new TestView(title, longTitle);
      };

      TestView.content = function(title) {
        return this.div(title);
      };

      TestView.prototype.initialize = function(title, longTitle) {
        this.title = title;
        this.longTitle = longTitle;
      };

      TestView.prototype.getTitle = function() {
        return this.title;
      };

      TestView.prototype.getLongTitle = function() {
        return this.longTitle;
      };

      TestView.prototype.serialize = function() {
        return {
          deserializer: 'TestView',
          title: this.title,
          longTitle: this.longTitle
        };
      };

      return TestView;

    })(View);
    beforeEach(function() {
      atom.workspaceView = new WorkspaceView;
      atom.workspace = atom.workspaceView.model;
      atom.deserializers.add(TestView);
      item1 = new TestView('Item 1');
      item2 = new TestView('Item 2');
      editor1 = atom.workspaceView.openSync('sample.js');
      pane = atom.workspaceView.getActivePane();
      pane.addItem(item1, 0);
      pane.addItem(item2, 2);
      pane.showItem(item2);
      return tabBar = new TabBarView(pane);
    });
    afterEach(function() {
      return atom.deserializers.remove(TestView);
    });
    describe(".initialize(pane)", function() {
      it("creates a tab for each item on the tab bar's parent pane", function() {
        expect(pane.getItems().length).toBe(3);
        expect(tabBar.find('.tab').length).toBe(3);
        expect(tabBar.find('.tab:eq(0) .title').text()).toBe(item1.getTitle());
        expect(tabBar.find('.tab:eq(1) .title').text()).toBe(editor1.getTitle());
        return expect(tabBar.find('.tab:eq(2) .title').text()).toBe(item2.getTitle());
      });
      it("highlights the tab for the active pane item", function() {
        return expect(tabBar.find('.tab:eq(2)')).toHaveClass('active');
      });
      return it("escapes html in the tooltip title", function() {
        var item3;
        spyOn(TabView.prototype, 'setTooltip');
        item3 = new TestView('Item 3');
        item3.getPath = function() {
          return "<img src='oh-my.jpg' />";
        };
        pane.showItem(item3);
        return expect(TabView.prototype.setTooltip.argsForCall[0][0].title).toBe(_.escape(item3.getPath()));
      });
    });
    describe("when the active pane item changes", function() {
      return it("highlights the tab for the new active pane item", function() {
        pane.showItem(item1);
        expect(tabBar.find('.active').length).toBe(1);
        expect(tabBar.find('.tab:eq(0)')).toHaveClass('active');
        pane.showItem(item2);
        expect(tabBar.find('.active').length).toBe(1);
        return expect(tabBar.find('.tab:eq(2)')).toHaveClass('active');
      });
    });
    describe("when a new item is added to the pane", function() {
      it("adds a tab for the new item at the same index as the item in the pane", function() {
        var item3;
        pane.showItem(item1);
        item3 = new TestView('Item 3');
        pane.showItem(item3);
        expect(tabBar.find('.tab').length).toBe(4);
        return expect(tabBar.tabAtIndex(1).find('.title')).toHaveText('Item 3');
      });
      return it("adds the 'modified' class to the new tab if the item is initially modified", function() {
        var editor2;
        editor2 = atom.project.openSync('sample.txt');
        editor2.insertText('x');
        pane.showItem(editor2);
        return expect(tabBar.tabForItem(editor2)).toHaveClass('modified');
      });
    });
    describe("when an item is removed from the pane", function() {
      it("removes the item's tab from the tab bar", function() {
        pane.removeItem(item2);
        expect(tabBar.getTabs().length).toBe(2);
        return expect(tabBar.find('.tab:contains(Item 2)')).not.toExist();
      });
      return it("updates the titles of the remaining tabs", function() {
        var item2a;
        expect(tabBar.tabForItem(item2)).toHaveText('Item 2');
        item2.longTitle = '2';
        item2a = new TestView('Item 2');
        item2a.longTitle = '2a';
        pane.showItem(item2a);
        expect(tabBar.tabForItem(item2)).toHaveText('2');
        expect(tabBar.tabForItem(item2a)).toHaveText('2a');
        pane.removeItem(item2a);
        return expect(tabBar.tabForItem(item2)).toHaveText('Item 2');
      });
    });
    describe("when a tab is clicked", function() {
      it("shows the associated item on the pane and focuses the pane", function() {
        spyOn(pane, 'focus');
        tabBar.tabAtIndex(0).trigger({
          type: 'click',
          which: 1
        });
        expect(pane.activeItem).toBe(pane.getItems()[0]);
        tabBar.tabAtIndex(2).trigger({
          type: 'click',
          which: 1
        });
        expect(pane.activeItem).toBe(pane.getItems()[2]);
        return expect(pane.focus.callCount).toBe(2);
      });
      return it("closes the tab when middle clicked", function() {
        var event;
        event = $.Event('mousedown');
        event.which = 2;
        tabBar.tabForItem(editor1).trigger(event);
        expect(pane.getItems().length).toBe(2);
        expect(pane.getItems().indexOf(editor1)).toBe(-1);
        expect(editor1.destroyed).toBeTruthy();
        expect(tabBar.getTabs().length).toBe(2);
        return expect(tabBar.find('.tab:contains(sample.js)')).not.toExist();
      });
    });
    describe("when a tab's close icon is clicked", function() {
      return it("destroys the tab's item on the pane", function() {
        tabBar.tabForItem(editor1).find('.close-icon').click();
        expect(pane.getItems().length).toBe(2);
        expect(pane.getItems().indexOf(editor1)).toBe(-1);
        expect(editor1.destroyed).toBeTruthy();
        expect(tabBar.getTabs().length).toBe(2);
        return expect(tabBar.find('.tab:contains(sample.js)')).not.toExist();
      });
    });
    describe("when a tab item's title changes", function() {
      return it("updates the title of the item's tab", function() {
        editor1.buffer.setPath('/this/is-a/test.txt');
        return expect(tabBar.tabForItem(editor1)).toHaveText('test.txt');
      });
    });
    describe("when two tabs have the same title", function() {
      return it("displays the long title on the tab if it's available from the item", function() {
        item1.title = "Old Man";
        item1.longTitle = "Grumpy Old Man";
        item1.trigger('title-changed');
        item2.title = "Old Man";
        item2.longTitle = "Jolly Old Man";
        item2.trigger('title-changed');
        expect(tabBar.tabForItem(item1)).toHaveText("Grumpy Old Man");
        expect(tabBar.tabForItem(item2)).toHaveText("Jolly Old Man");
        item2.longTitle = void 0;
        item2.trigger('title-changed');
        expect(tabBar.tabForItem(item1)).toHaveText("Grumpy Old Man");
        return expect(tabBar.tabForItem(item2)).toHaveText("Old Man");
      });
    });
    describe("when a tab item's modified status changes", function() {
      return it("adds or removes the 'modified' class to the tab based on the status", function() {
        var tab;
        tab = tabBar.tabForItem(editor1);
        expect(editor1.isModified()).toBeFalsy();
        expect(tab).not.toHaveClass('modified');
        editor1.insertText('x');
        advanceClock(editor1.buffer.stoppedChangingDelay);
        expect(editor1.isModified()).toBeTruthy();
        expect(tab).toHaveClass('modified');
        editor1.undo();
        advanceClock(editor1.buffer.stoppedChangingDelay);
        expect(editor1.isModified()).toBeFalsy();
        return expect(tab).not.toHaveClass('modified');
      });
    });
    describe("when a pane item moves to a new index", function() {
      return it("updates the order of the tabs to match the new item order", function() {
        expect(tabBar.getTabs().map(function(tab) {
          return tab.text();
        })).toEqual(["Item 1", "sample.js", "Item 2"]);
        pane.moveItem(item2, 1);
        expect(tabBar.getTabs().map(function(tab) {
          return tab.text();
        })).toEqual(["Item 1", "Item 2", "sample.js"]);
        pane.moveItem(editor1, 0);
        expect(tabBar.getTabs().map(function(tab) {
          return tab.text();
        })).toEqual(["sample.js", "Item 1", "Item 2"]);
        pane.moveItem(item1, 2);
        return expect(tabBar.getTabs().map(function(tab) {
          return tab.text();
        })).toEqual(["sample.js", "Item 2", "Item 1"]);
      });
    });
    describe("context menu commands", function() {
      describe("when tabs:close-tab is fired", function() {
        return it("closes the active tab", function() {
          $(tabBar.tabForItem(item2)).trigger({
            type: 'mousedown',
            which: 3
          });
          tabBar.trigger('tabs:close-tab');
          expect(pane.getItems().length).toBe(2);
          expect(pane.getItems().indexOf(item2)).toBe(-1);
          expect(tabBar.getTabs().length).toBe(2);
          return expect(tabBar.find('.tab:contains(Item 2)')).not.toExist();
        });
      });
      describe("when tabs:close-other-tabs is fired", function() {
        return it("closes all other tabs except the active tab", function() {
          $(tabBar.tabForItem(item2)).trigger({
            type: 'mousedown',
            which: 3
          });
          tabBar.trigger('tabs:close-other-tabs');
          expect(pane.getItems().length).toBe(1);
          expect(tabBar.getTabs().length).toBe(1);
          expect(tabBar.find('.tab:contains(sample.js)')).not.toExist();
          return expect(tabBar.find('.tab:contains(Item 2)')).toExist();
        });
      });
      return describe("when tabs:close-tabs-to-right is fired", function() {
        return it("closes only the tabs to the right of the active tab", function() {
          pane.showItem(editor1);
          $(tabBar.tabForItem(editor1)).trigger({
            type: 'mousedown',
            which: 3
          });
          tabBar.trigger('tabs:close-tabs-to-right');
          expect(pane.getItems().length).toBe(2);
          expect(tabBar.getTabs().length).toBe(2);
          expect(tabBar.find('.tab:contains(Item 2)')).not.toExist();
          return expect(tabBar.find('.tab:contains(Item 1)')).toExist();
        });
      });
    });
    describe("dragging and dropping tabs", function() {
      var buildDragEvents;
      buildDragEvents = function(dragged, dropTarget) {
        var dataTransfer, dragStartEvent, dropEvent;
        dataTransfer = {
          data: {},
          setData: function(key, value) {
            return this.data[key] = value;
          },
          getData: function(key) {
            return this.data[key];
          }
        };
        dragStartEvent = $.Event();
        dragStartEvent.target = dragged[0];
        dragStartEvent.originalEvent = {
          dataTransfer: dataTransfer
        };
        dropEvent = $.Event();
        dropEvent.target = dropTarget[0];
        dropEvent.originalEvent = {
          dataTransfer: dataTransfer
        };
        return [dragStartEvent, dropEvent];
      };
      describe("when a tab is dragged within the same pane", function() {
        describe("when it is dropped on tab that's later in the list", function() {
          return it("moves the tab and its item, shows the tab's item, and focuses the pane", function() {
            var dragStartEvent, dropEvent, _ref2;
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            spyOn(pane, 'focus');
            _ref2 = buildDragEvents(tabBar.tabAtIndex(0), tabBar.tabAtIndex(1)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
            tabBar.onDragStart(dragStartEvent);
            tabBar.onDrop(dropEvent);
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["sample.js", "Item 1", "Item 2"]);
            expect(pane.getItems()).toEqual([editor1, item1, item2]);
            expect(pane.activeItem).toBe(item1);
            return expect(pane.focus).toHaveBeenCalled();
          });
        });
        describe("when it is dropped on a tab that's earlier in the list", function() {
          return it("moves the tab and its item, shows the tab's item, and focuses the pane", function() {
            var dragStartEvent, dropEvent, _ref2;
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            spyOn(pane, 'focus');
            _ref2 = buildDragEvents(tabBar.tabAtIndex(2), tabBar.tabAtIndex(0)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
            tabBar.onDragStart(dragStartEvent);
            tabBar.onDrop(dropEvent);
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "Item 2", "sample.js"]);
            expect(pane.getItems()).toEqual([item1, item2, editor1]);
            expect(pane.activeItem).toBe(item2);
            return expect(pane.focus).toHaveBeenCalled();
          });
        });
        describe("when it is dropped on itself", function() {
          return it("doesn't move the tab or item, but does make it the active item and focuses the pane", function() {
            var dragStartEvent, dropEvent, _ref2;
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            spyOn(pane, 'focus');
            _ref2 = buildDragEvents(tabBar.tabAtIndex(0), tabBar.tabAtIndex(0)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
            tabBar.onDragStart(dragStartEvent);
            tabBar.onDrop(dropEvent);
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item1);
            return expect(pane.focus).toHaveBeenCalled();
          });
        });
        return describe("when it is dropped on the tab bar", function() {
          return it("moves the tab and its item to the end", function() {
            var dragStartEvent, dropEvent, _ref2;
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            spyOn(pane, 'focus');
            _ref2 = buildDragEvents(tabBar.tabAtIndex(0), tabBar), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
            tabBar.onDragStart(dragStartEvent);
            tabBar.onDrop(dropEvent);
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["sample.js", "Item 2", "Item 1"]);
            return expect(pane.getItems()).toEqual([editor1, item2, item1]);
          });
        });
      });
      describe("when a tab is dragged to a different pane", function() {
        var item2b, pane2, tabBar2, _ref2;
        _ref2 = [], pane2 = _ref2[0], tabBar2 = _ref2[1], item2b = _ref2[2];
        beforeEach(function() {
          pane2 = pane.splitRight(pane.copyActiveItem());
          item2b = pane2.getItems()[0];
          return tabBar2 = new TabBarView(pane2);
        });
        it("removes the tab and item from their original pane and moves them to the target pane", function() {
          var dragStartEvent, dropEvent, _ref3;
          expect(tabBar.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["Item 1", "sample.js", "Item 2"]);
          expect(pane.getItems()).toEqual([item1, editor1, item2]);
          expect(pane.activeItem).toBe(item2);
          expect(tabBar2.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["Item 2"]);
          expect(pane2.getItems()).toEqual([item2b]);
          expect(pane2.activeItem).toBe(item2b);
          spyOn(pane2, 'focus');
          _ref3 = buildDragEvents(tabBar.tabAtIndex(0), tabBar2.tabAtIndex(0)), dragStartEvent = _ref3[0], dropEvent = _ref3[1];
          tabBar.onDragStart(dragStartEvent);
          tabBar.onDrop(dropEvent);
          expect(tabBar.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["sample.js", "Item 2"]);
          expect(pane.getItems()).toEqual([editor1, item2]);
          expect(pane.activeItem).toBe(item2);
          expect(tabBar2.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["Item 2", "Item 1"]);
          expect(pane2.getItems()).toEqual([item2b, item1]);
          expect(pane2.activeItem).toBe(item1);
          return expect(pane2.focus).toHaveBeenCalled();
        });
        return describe("when the tab is dragged to an empty pane", function() {
          return it("removes the tab and item from their original pane and moves them to the target pane", function() {
            var dragStartEvent, dropEvent, _ref3;
            pane2.destroyItems();
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1", "sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([item1, editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            expect(tabBar2.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual([]);
            expect(pane2.getItems()).toEqual([]);
            expect(pane2.activeItem).toBeUndefined();
            spyOn(pane2, 'focus');
            _ref3 = buildDragEvents(tabBar.tabAtIndex(0), tabBar2), dragStartEvent = _ref3[0], dropEvent = _ref3[1];
            tabBar.onDragStart(dragStartEvent);
            tabBar.onDrop(dropEvent);
            expect(tabBar.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["sample.js", "Item 2"]);
            expect(pane.getItems()).toEqual([editor1, item2]);
            expect(pane.activeItem).toBe(item2);
            expect(tabBar2.getTabs().map(function(tab) {
              return tab.text();
            })).toEqual(["Item 1"]);
            expect(pane2.getItems()).toEqual([item1]);
            expect(pane2.activeItem).toBe(item1);
            return expect(pane2.focus).toHaveBeenCalled();
          });
        });
      });
      describe("when a non-tab is dragged to pane", function() {
        return it("has no effect", function() {
          var dragStartEvent, dropEvent, _ref2;
          expect(tabBar.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["Item 1", "sample.js", "Item 2"]);
          expect(pane.getItems()).toEqual([item1, editor1, item2]);
          expect(pane.activeItem).toBe(item2);
          spyOn(pane, 'focus');
          _ref2 = buildDragEvents(tabBar.tabAtIndex(0), tabBar.tabAtIndex(0)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
          tabBar.onDrop(dropEvent);
          expect(tabBar.getTabs().map(function(tab) {
            return tab.text();
          })).toEqual(["Item 1", "sample.js", "Item 2"]);
          expect(pane.getItems()).toEqual([item1, editor1, item2]);
          expect(pane.activeItem).toBe(item2);
          return expect(pane.focus).not.toHaveBeenCalled();
        });
      });
      describe("when a tab is dragged out of application", function() {
        return it("should carry the file's information", function() {
          var dragStartEvent, dropEvent, _ref2;
          _ref2 = buildDragEvents(tabBar.tabAtIndex(1), tabBar.tabAtIndex(1)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
          tabBar.onDragStart(dragStartEvent);
          expect(dragStartEvent.originalEvent.dataTransfer.getData("text/plain")).toEqual(editor1.getPath());
          return expect(dragStartEvent.originalEvent.dataTransfer.getData("text/uri-list")).toEqual('file://' + editor1.getPath());
        });
      });
      return describe("when a tab is dragged to another Atom window", function() {
        it("closes the tab in the first window and opens the tab in the second window", function() {
          var dragStartEvent, dropEvent, _ref2;
          _ref2 = buildDragEvents(tabBar.tabAtIndex(1), tabBar.tabAtIndex(0)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
          tabBar.onDragStart(dragStartEvent);
          tabBar.onDropOnOtherWindow(pane.model.id, 1);
          expect(pane.getItems()).toEqual([item1, item2]);
          expect(pane.activeItem).toBe(item2);
          dropEvent.originalEvent.dataTransfer.setData('from-process-id', tabBar.getProcessId() + 1);
          spyOn(tabBar, 'moveItemBetweenPanes').andCallThrough();
          tabBar.onDrop(dropEvent);
          waitsFor(function() {
            return tabBar.moveItemBetweenPanes.callCount > 0;
          });
          return runs(function() {
            var editor;
            editor = atom.workspace.getActiveEditor();
            expect(editor.getPath()).toBe(editor1.getPath());
            return expect(pane.getItems()).toEqual([item1, editor, item2]);
          });
        });
        return it("transfers the text of the editor when it is modified", function() {
          var dragStartEvent, dropEvent, _ref2;
          editor1.setText('I came from another window');
          _ref2 = buildDragEvents(tabBar.tabAtIndex(1), tabBar.tabAtIndex(0)), dragStartEvent = _ref2[0], dropEvent = _ref2[1];
          tabBar.onDragStart(dragStartEvent);
          tabBar.onDropOnOtherWindow(pane.model.id, 1);
          dropEvent.originalEvent.dataTransfer.setData('from-process-id', tabBar.getProcessId() + 1);
          spyOn(tabBar, 'moveItemBetweenPanes').andCallThrough();
          tabBar.onDrop(dropEvent);
          waitsFor(function() {
            return tabBar.moveItemBetweenPanes.callCount > 0;
          });
          return runs(function() {
            return expect(atom.workspace.getActiveEditor().getText()).toBe('I came from another window');
          });
        });
      });
    });
    return describe("when the tab bar is double clicked", function() {
      return it("opens a new empty editor", function() {
        var newFileHandler;
        newFileHandler = jasmine.createSpy('newFileHandler');
        atom.workspaceView.on('application:new-file', newFileHandler);
        tabBar.getTabs()[0].dblclick();
        expect(newFileHandler.callCount).toBe(0);
        tabBar.dblclick();
        return expect(newFileHandler.callCount).toBe(1);
      });
    });
  });

}).call(this);

//# sourceMappingURL=/../../../../../../../../..//tmp/atom-build/Atom.app/Contents/Resources/app/node_modules/tabs/spec/tabs-spec.js.map
