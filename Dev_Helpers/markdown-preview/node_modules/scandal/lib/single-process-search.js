(function() {
  var MAX_CONCURRENT_SEARCH, PathReplacer, PathScanner, PathSearcher, replaceMain, scanMain, search, searchMain;

  PathSearcher = require('./path-searcher');

  PathScanner = require('./path-scanner');

  PathReplacer = require('./path-replacer');

  MAX_CONCURRENT_SEARCH = 20;

  /*
  Single Process
  */


  search = function(regex, scanner, searcher, doneCallback) {
    var checkIfFinished, finish, finishedScanning, globalizeRegex, maybeSearchPath, onFinishedScanning, pathCount, pathQueue, pathsSearching, searchNextPath, searchPath,
      _this = this;
    finishedScanning = false;
    pathCount = 0;
    pathsSearching = 0;
    pathQueue = [];
    globalizeRegex = function(regex) {
      var flags;
      if (!regex.global) {
        flags = "g";
        if (regex.ignoreCase) {
          flags += "i";
        }
        if (regex.multiline) {
          flags += "m";
        }
        regex = new RegExp(regex.source, flags);
      }
      return regex;
    };
    searchPath = function(filePath) {
      pathsSearching++;
      return searcher.searchPath(regex, filePath, function() {
        pathCount--;
        pathsSearching--;
        return checkIfFinished();
      });
    };
    searchNextPath = function() {
      if (pathsSearching < MAX_CONCURRENT_SEARCH && pathQueue.length) {
        return searchPath(pathQueue.shift());
      }
    };
    maybeSearchPath = function(filePath) {
      pathCount++;
      if (pathsSearching < MAX_CONCURRENT_SEARCH) {
        return searchPath(filePath);
      } else {
        return pathQueue.push(filePath);
      }
    };
    onFinishedScanning = function() {
      finishedScanning = true;
      return checkIfFinished();
    };
    checkIfFinished = function() {
      searchNextPath();
      if (finishedScanning && pathCount === 0) {
        return finish();
      }
    };
    finish = function() {
      scanner.removeListener('path-found', maybeSearchPath);
      scanner.removeListener('finished-scanning', onFinishedScanning);
      return doneCallback();
    };
    regex = globalizeRegex(regex);
    scanner.on('path-found', maybeSearchPath);
    scanner.on('finished-scanning', onFinishedScanning);
    return scanner.scan();
  };

  searchMain = function(options) {
    var count, pathCount, resultCount, scanner, searcher;
    searcher = new PathSearcher();
    scanner = new PathScanner(options.pathToScan, options);
    console.time('Single Process Search');
    count = 0;
    resultCount = 0;
    pathCount = 0;
    scanner.on('path-found', function(path) {
      return pathCount++;
    });
    searcher.on('results-found', function(results) {
      var match, _i, _len, _ref, _results;
      count++;
      if (options.verbose) {
        console.log(results.filePath);
      }
      _ref = results.matches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        match = _ref[_i];
        resultCount++;
        if (options.verbose) {
          _results.push(console.log('  ', match.range[0][0] + ":", match.matchText, 'at', match.range));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    return search(new RegExp(options.search, 'gi'), scanner, searcher, function() {
      console.timeEnd('Single Process Search');
      return console.log("" + resultCount + " matches in " + count + " files. Searched " + pathCount + " files");
    });
  };

  replaceMain = function(options) {
    var paths, regex, replacer, scanner, totalFiles, totalReplacements;
    scanner = new PathScanner(options.pathToScan, options);
    replacer = new PathReplacer({
      dryReplace: options.dryReplace
    });
    regex = new RegExp(options.search, 'gi');
    console.time('Single Process Search + Replace');
    paths = [];
    scanner.on('path-found', function(p) {
      return paths.push(p);
    });
    totalReplacements = 0;
    totalFiles = 0;
    replacer.on('path-replaced', function(_arg) {
      var filePath, replacements;
      filePath = _arg.filePath, replacements = _arg.replacements;
      totalFiles++;
      totalReplacements += replacements;
      if (options.verbose) {
        return console.log('Replaced', replacements, 'in', filePath);
      }
    });
    scanner.on('finished-scanning', function() {
      return replacer.replacePaths(regex, options.replace, paths, function() {
        console.timeEnd('Single Process Search + Replace');
        return console.log("Replaced " + totalReplacements + " matches in " + totalFiles + " files");
      });
    });
    return scanner.scan();
  };

  scanMain = function(options) {
    var count, scanner;
    scanner = new PathScanner(options.pathToScan, options);
    console.time('Single Process Scan');
    count = 0;
    scanner.on('path-found', function(path) {
      count++;
      if (options.verbose) {
        return console.log(path);
      }
    });
    scanner.on('finished-scanning', function() {
      console.timeEnd('Single Process Scan');
      return console.log("Found " + count + " paths");
    });
    return scanner.scan();
  };

  module.exports = {
    scanMain: scanMain,
    searchMain: searchMain,
    replaceMain: replaceMain,
    search: search
  };

}).call(this);
