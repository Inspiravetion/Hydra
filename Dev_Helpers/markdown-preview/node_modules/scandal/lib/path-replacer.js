(function() {
  var ChunkedLineReader, EOL, EventEmitter, PathReplacer, ReplaceTransformer, Transform, fs, temp, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  fs = require('fs');

  temp = require('temp');

  EventEmitter = require('events').EventEmitter;

  Transform = require('stream').Transform;

  EOL = require('os').EOL;

  ChunkedLineReader = require('./chunked-line-reader');

  ReplaceTransformer = (function(_super) {
    __extends(ReplaceTransformer, _super);

    function ReplaceTransformer(regex, replacementText, _arg) {
      this.regex = regex;
      this.replacementText = replacementText;
      this.dryReplace = _arg.dryReplace;
      this.replacements = 0;
      ReplaceTransformer.__super__.constructor.call(this);
    }

    ReplaceTransformer.prototype._transform = function(chunk, encoding, done) {
      var data, matches;
      data = chunk.toString();
      matches = data.match(this.regex);
      if (matches) {
        this.replacements += matches.length;
      }
      if (!this.dryReplace) {
        data = data.replace(this.regex, this.replacementText);
      }
      this.push(data, 'utf8');
      return done();
    };

    return ReplaceTransformer;

  })(Transform);

  module.exports = PathReplacer = (function(_super) {
    __extends(PathReplacer, _super);

    function PathReplacer(_arg) {
      this.dryReplace = (_arg != null ? _arg : {}).dryReplace;
    }

    PathReplacer.prototype.replacePaths = function(regex, replacementText, paths, doneCallback) {
      var filePath, pathsReplaced, results, _i, _len, _results;
      results = null;
      pathsReplaced = 0;
      _results = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        filePath = paths[_i];
        _results.push(this.replacePath(regex, replacementText, filePath, function(result) {
          if (result) {
            if (results == null) {
              results = [];
            }
            results.push(result);
          }
          if (++pathsReplaced === paths.length) {
            return doneCallback(results);
          }
        }));
      }
      return _results;
    };

    PathReplacer.prototype.replacePath = function(regex, replacementText, filePath, doneCallback) {
      var output, reader, replacer,
        _this = this;
      reader = new ChunkedLineReader(filePath);
      if (reader.isBinaryFile()) {
        return doneCallback(null);
      }
      replacer = new ReplaceTransformer(regex, replacementText, {
        dryReplace: this.dryReplace
      });
      output = temp.createWriteStream();
      output.on('finish', function() {
        var origStat, replacements, result, tempStat;
        result = null;
        if (replacements = replacer.replacements) {
          result = {
            filePath: filePath,
            replacements: replacements
          };
          _this.emit('path-replaced', result);
        }
        tempStat = fs.statSync(output.path);
        origStat = fs.statSync(filePath);
        if (origStat.mode !== tempStat.mode) {
          fs.chmodSync(output.path, origStat.mode);
        }
        fs.renameSync(output.path, filePath);
        return doneCallback(result);
      });
      return reader.pipe(replacer).pipe(output);
    };

    return PathReplacer;

  })(EventEmitter);

}).call(this);
